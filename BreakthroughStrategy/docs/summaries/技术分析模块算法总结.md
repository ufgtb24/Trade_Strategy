# 技术分析模块算法总结

**模块路径**: `BreakthroughStrategy/analysis/`
**最新更新**: 2025-11-18（增量式重构）

---

## 一、核心思想

### 突破选股策略的本质

```
历史阻力位 → 突破 → 上涨信号
```

**关键洞察**：
- 股价突破**强阻力位**比突破**弱阻力位**更有意义
- **密集阻力区**（多个峰值聚集）一旦突破，动能更强
- 一次突破可能同时突破**多个历史峰值**

### 算法架构演进

```
旧架构（批量式）:
  找到所有峰值 → 对每个峰值查找突破 → 单峰值对应单突破
  问题：无法识别"一次突破突破了多少个峰值"

新架构（增量式）:
  增量添加价格 → 维护活跃峰值 → 检测突破（返回所有被突破峰值）
  优势：天然支持多峰值突破，适合实时监控
```

---

## 二、核心算法

### 2.1 峰值检测与管理（增量式）

**目标**：维护"当前有效的阻力位列表"

#### 算法流程

```
初始化: active_peaks = []

for each new_bar:
    # 1. 检查是否突破活跃峰值
    broken_peaks = []
    for peak in active_peaks:
        if new_bar.high > peak.price × 1.005:
            broken_peaks.append(peak)  # 突破了

    # 移除已突破的峰值
    active_peaks.remove(broken_peaks)

    # 2. 检查当前位置是否形成新峰值
    if is_local_maximum(current_index - window):
        new_peak = create_peak(...)

        # 决定是否保留旧峰值（关键创新）
        for old_peak in active_peaks:
            if new_peak.price > old_peak.price:
                exceed_pct = (new_peak - old_peak) / old_peak

                if exceed_pct < 3%:  # peak_merge_threshold
                    保留old_peak  # 形成阻力区
                else:
                    删除old_peak  # 已被明显超越

        active_peaks.append(new_peak)
```

**局部最高点判断**：
```
if high[i] > max(high[i-5:i]) AND high[i] > max(high[i+1:i+6]):
    → 当前K线是峰值（比前后各5天都高）
```

**峰值共存策略**（核心创新）：
```
案例：历史峰值演变
t1: 峰值A=100 → active=[A]
t2: 峰值B=102 → 超过A 2%, <3% → active=[A, B]  # 形成阻力区
t3: 峰值C=108 → 超过A 8%, >3% → active=[B, C]  # A被覆盖，删除
```

**效果**：
- ✅ 识别密集阻力区（多个峰值价格接近）
- ✅ 自动清理被明显超越的旧峰值
- ✅ 一次突破可能突破多个峰值

---

### 2.2 突破检测（多峰值支持）

**目标**：检测价格突破活跃阻力位

#### 算法核心

```
for each new_bar:
    broken_peaks = []

    for peak in active_peaks:
        if new_bar.high > peak.price × 1.005:  # 0.5%确认阈值
            broken_peaks.append(peak)

    if broken_peaks:
        return BreakoutInfo(
            current_price=new_bar.high,
            current_date=new_bar.date,
            broken_peaks=broken_peaks  # 关键：多个峰值
        )
```

**突破确认**：使用最高价 + 0.5%阈值（减少假突破）

**突破信息**：
- `num_peaks_broken`: 突破的峰值数量（1-5个）
- `peak_price_range`: 被突破峰值的价格范围
- `highest_peak_broken`: 最高峰值

---

### 2.3 质量评分（改进版）

**目标**：0-100分评估突破质量

#### 峰值质量评分

```
峰值质量 = 放量(25%) + 长K线(20%) + 压制时间(25%) + 相对高度(15%) + 默认(15%)
```

**评分方法**：线性映射（例：放量2倍=0分，5倍=100分）

#### 突破质量评分（重新设计）

```
突破质量 = 涨跌幅(20%) + 跳空(10%) + 放量(20%)
         + 连续性(15%) + 稳定性(15%)
         + 阻力强度(20%)  ← 新增综合指标
```

**阻力强度**（核心创新）：
```
阻力强度 = 峰值数量(30%) + 峰值密集度(30%) + 峰值质量(40%)

1. 峰值数量：
   - 突破1个峰值 = 30分
   - 突破3个峰值 = 60分
   - 突破5个峰值 = 100分

2. 峰值密集度（修复：识别密集子集）：
   - 找到最大密集子集（价格范围<3%）
   - 密集子集大小≥3 → 80分基础分
   - 密集度<1% → +20分加成
   - 有密集区+分散峰值 → +10分多样性加成

   案例：
   [3.6, 3.79, 3.81, 3.82, 3.9]
   → 识别出密集子集[3.79-3.82] (0.79%)
   → 基础80 + 密集20 + 多样性10 = 110 → 100分（封顶）

3. 峰值质量：
   - 平均质量（主要）
   - 最高质量加成（max≥80 → +10分）
   - 一致性加成（min≥60 → +10分）
```

**关键修复**：
- ❌ 旧算法：看整体价格范围 → `[3.6, 3.9]`范围8% → 低分
- ✅ 新算法：识别密集子集 → 发现`[3.79-3.82]`密集区 → 高分

---

## 三、数据流图（新架构）

```
┌─────────────────────────────────────────┐
│  输入: DataFrame (OHLCV)                 │
└──────────────┬──────────────────────────┘
               │
               │ 增量添加每根K线
               ▼
    ┌──────────────────────┐
    │ BreakthroughDetector  │  核心：增量式架构
    │                       │
    │ 状态：                │
    │  - prices[]          │  所有价格历史
    │  - active_peaks[]    │  活跃峰值列表
    │                       │
    │ 每根K线：             │
    │  1. 检查突破          │ → BreakoutInfo (多峰值)
    │  2. 更新活跃峰值      │
    └──────────┬────────────┘
               │
               ▼
        List[BreakoutInfo]
        (59个突破，10个多峰值)
               │
               ▼
    ┌──────────────────────┐
    │  FeatureCalculator    │  计算丰富特征
    │                       │
    │  - 突破类型           │
    │  - 涨跌幅、跳空       │
    │  - 放量、连续性       │
    │  - 稳定性             │
    └──────────┬────────────┘
               │
               ▼
        List[Breakthrough]
        (包含完整特征)
               │
               ▼
    ┌──────────────────────┐
    │   QualityScorer       │  改进的评分系统
    │                       │
    │  峰值评分 → Peak      │
    │  突破评分 → BT        │
    │   (阻力强度：         │
    │    数量+密集度+质量)  │
    └──────────┬────────────┘
               │
               ▼
         高质量突破
        (quality > 40)
               │
               ▼
          交易信号
```

---

## 四、测试结果对比

### AAPL (1255天数据)

| 指标 | 旧版本 | 新版本 | 变化 |
|------|--------|--------|------|
| **突破识别数** | 18个 | 59个 | +228% |
| **多峰值突破** | 0个 | 10个 | - |
| **平均评分** | 20.5分 | 23.2分 | +2.7分 |
| **最高评分** | 46.9分 | 49.0分 | +2.1分 |

### 多峰值突破案例

```
日期: 2023-03-20
突破价格: $155.09

突破了3个峰值:
  峰值1: $154.31 (质量48.3) 压制95天
  峰值2: $153.60 (质量22.5) 压制20天
  峰值3: $153.57 (质量22.5) 压制9天

阻力区分析:
  价格范围: $153.57 ~ $154.31
  密集度: 0.48% ← 极强阻力区

评分: 23.8/100
```

**关键洞察**：
- ✅ 识别出密集阻力区 `[153.57-154.31]`
- ✅ 一次突破同时突破3个峰值
- ✅ 密集度0.48% < 1% → 获得密集度加成

---

## 五、使用示例

### 基本用法（回测场景）

```python
from BreakthroughStrategy.analysis import (
    BreakthroughDetector,
    FeatureCalculator,
    QualityScorer
)

# 1. 创建检测器（增量式，不使用缓存）
detector = BreakthroughDetector(
    symbol='AAPL',
    window=5,                    # 峰值识别窗口
    exceed_threshold=0.005,      # 0.5%突破确认阈值
    peak_merge_threshold=0.03,   # 3%峰值共存阈值
    use_cache=False              # 回测不需要缓存
)

# 2. 批量添加历史数据
breakout_infos = detector.batch_add_bars(df, return_breakouts=True)

# 3. 计算特征和评分
feature_calc = FeatureCalculator()
scorer = QualityScorer()

breakthroughs = []
for info in breakout_infos:
    # 为峰值评分
    for peak in info.broken_peaks:
        scorer.score_peak(peak)

    # 计算突破特征
    bt = feature_calc.enrich_breakthrough(df, info, 'AAPL')
    breakthroughs.append(bt)

# 突破质量评分
scorer.score_breakthroughs_batch(breakthroughs)

# 4. 筛选高质量突破
high_quality = [bt for bt in breakthroughs if bt.quality_score > 40]
```

### 实时监控场景

```python
# 创建检测器（启用缓存）
detector = BreakthroughDetector(
    symbol='AAPL',
    use_cache=True  # 实时监控使用缓存
)

# 初始化历史数据（一次性）
history = load_data('AAPL', days=500)
detector.batch_add_bars(history)

# 实时循环
while True:
    new_bar = get_latest_bar('AAPL')
    breakout_info = detector.add_bar(new_bar)  # O(1) 增量更新

    if breakout_info:
        bt = feature_calc.enrich_breakthrough(df, breakout_info, 'AAPL')
        scorer.score_breakthrough(bt)

        if bt.quality_score > 70:
            send_alert(bt)  # 高质量突破信号
```

---

## 六、核心优势

### 1. 增量式架构

| 场景 | 旧版本 | 新版本 |
|------|--------|--------|
| 添加1个新数据点 | O(N) 重新扫描全部 | O(1) 增量更新 |
| 程序重启后继续 | O(N) 重新加载 | O(1) 从缓存恢复 |
| 实时监控100只股票 | 每次O(100×N) | 每次O(100) |

### 2. 多峰值突破

- ✅ 识别密集阻力区（多个峰值价格接近）
- ✅ 统计"一次突破突破了多少个峰值"
- ✅ 区分"突破强阻力"和"突破弱阻力"

### 3. 改进的评分系统

**修复的问题**：
- ❌ 旧版：密集区+分散峰值 → 被整体范围拉低 → 低分
- ✅ 新版：识别密集子集 → 密集度加成+多样性加成 → 高分

**新增的维度**：
- ✅ 综合所有被突破峰值的质量
- ✅ 峰值质量一致性加成
- ✅ 阻力强度占突破评分20%权重

---

## 七、关键参数

### BreakthroughDetector

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `window` | 5 | 峰值识别窗口（前后各5天） |
| `exceed_threshold` | 0.005 | 突破确认阈值（0.5%） |
| `peak_merge_threshold` | 0.03 | 峰值共存阈值（3%） |
| `use_cache` | False | 是否持久化缓存 |

**调参建议**：
- `window` ↑ → 识别更强的阻力位，但峰值数量↓
- `exceed_threshold` ↑ → 更严格的突破确认，减少假突破
- `peak_merge_threshold` ↑ → 更多峰值共存，更多多峰值突破

---

## 八、总结

### 核心创新

1. **增量式架构** → 实时监控O(1)，程序重启可恢复
2. **峰值共存策略** → 识别密集阻力区
3. **多峰值突破** → "突破了多少个峰值"
4. **改进评分系统** → 修复密集度bug，综合峰值质量

### 算法统一性

```
同一套增量式算法:
  ✓ 历史回测（use_cache=False）
  ✓ 实时监控（use_cache=True）
  ✓ 参数优化（批量添加数据）

保证：回测结果 = 实盘结果
```

### 适用场景

| 场景 | 适用性 | 说明 |
|------|--------|------|
| **实时监控** | ⭐️⭐️⭐️⭐️⭐️ | 增量更新，支持缓存恢复 |
| **历史回测** | ⭐️⭐️⭐️⭐️⭐️ | 批量添加，算法一致 |
| **质量筛选** | ⭐️⭐️⭐️⭐️⭐️ | 改进的多维度评分 |
| **参数优化** | ⭐️⭐️⭐️⭐️ | 可配置权重和阈值 |

---

**文档版本**: v2.0 (增量式重构版)
**更新日期**: 2025-11-18
**作者**: Claude Code
