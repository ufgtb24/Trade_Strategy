# 交互式UI系统实施方案

**创建日期**: 2025-11-26
**目标**: 创建交互式UI程序，支持批量扫描和交互式查看突破检测结果

---

## 一、需求总结

### 核心功能
1. **批量扫描系统**: 并行扫描10855只股票，保存扫描结果到JSON
2. **交互式查看系统**: 加载JSON结果，支持筛选、排序、实时参数调整
3. **参数配置**: 灵活的参数管理（Spinbox + 防抖机制）
4. **键盘导航**: 上下键切换股票，快捷键操作
5. **鼠标悬停**: 显示K线详细数据（日期、价格、成交量等）

### 保留能力
- ✅ 保留 `visual_demo.py` 和静态图片生成
- ✅ 保留 `BreakthroughPlotter` 及所有组件
- ✅ 不修改现有可视化模块代码

### 明确不需要
- ❌ 全屏模式功能

---

## 二、架构设计

### 双阶段工作流

```
[阶段一: 批量扫描 - 离线处理]
datasets/pkls/*.pkl → ScanManager (并行) → scan_results/*.json

[阶段二: 交互式查看 - 实时交互]
JSON结果 → UI加载 → 筛选/排序 → 选择股票 → 图表显示
                                    ↓
                              参数调整 → 重新检测 → 刷新图表
```

### 目录结构

```
BreakthroughStrategy/visualization/interactive/
├── __init__.py
├── scan_manager.py          # 批量扫描管理器
├── interactive_ui.py        # 主窗口
├── stock_list_panel.py      # 股票列表管理
├── parameter_panel.py       # 参数配置面板
├── chart_canvas_manager.py  # 图表Canvas管理
├── navigation_manager.py    # 键盘导航管理
└── utils.py                 # 工具函数

scripts/
├── batch_scan.py           # 批量扫描脚本
└── interactive_viewer.py   # 交互式查看器启动脚本
```

---

## 三、核心模块设计

### 3.1 ScanManager (scan_manager.py)

**职责**: 批量扫描股票并保存结果

**关键方法**:
```python
class ScanManager:
    def scan_stock(self, symbol: str, data_dir: str) -> Dict
        """扫描单只股票，返回结果字典"""

    def parallel_scan(self, symbols: List[str], num_workers: int = 8) -> List[Dict]
        """并行扫描多只股票（使用multiprocessing.Pool）"""

    def save_results(self, results: List[Dict], output_path: str)
        """保存扫描结果为JSON"""

    def load_results(self, input_path: str) -> Dict
        """加载已保存的扫描结果"""
```

**JSON结果格式**:
```json
{
  "scan_metadata": {
    "scan_date": "2025-11-26T14:30:00",
    "total_stocks": 10855,
    "stocks_scanned": 10800,
    "scan_errors": 55
  },
  "results": [
    {
      "symbol": "AAPL",
      "data_points": 2500,
      "active_peaks": 12,
      "total_breakthroughs": 45,
      "breakthroughs": [
        {
          "date": "2025-01-15",
          "price": 182.50,
          "index": 1234,
          "num_peaks_broken": 2,
          "quality_score": 78.5,
          "broken_peaks": [...]
        }
      ]
    }
  ]
}
```

**并行处理方案**:
- 使用 `multiprocessing.Pool(processes=8)`
- 每100只股票保存checkpoint（支持断点恢复）
- 性能目标: 10855只股票 < 10分钟

---

### 3.2 InteractiveUI (interactive_ui.py)

**职责**: 主窗口，协调各面板和管理器

**布局设计**:
```
┌─────────────────────────────────────────────────────┐
│  参数面板 (ParameterPanel)                           │
│  [加载结果] [Window: 5] [Threshold: 0.005] [刷新]  │
├────────────────┬────────────────────────────────────┤
│                │                                    │
│  股票列表       │        图表Canvas                   │
│  (StockList)   │   (ChartCanvasManager)            │
│                │                                    │
│  [Treeview]    │   [FigureCanvasTkAgg嵌入]         │
│  - 筛选        │   - 复用BreakthroughPlotter       │
│  - 排序        │   - 防内存泄漏                     │
│  - 导航        │                                    │
│                │                                    │
└────────────────┴────────────────────────────────────┘
```

**关键方法**:
```python
class InteractiveUI:
    def __init__(self, root)
        """初始化主窗口和子面板"""

    def load_scan_results(self, json_path: str)
        """加载扫描结果JSON"""

    def on_stock_selected(self, symbol: str)
        """股票选择事件：加载数据并显示图表"""

    def on_param_changed(self)
        """参数变化事件：防抖后刷新图表"""
```

---

### 3.3 StockListPanel (stock_list_panel.py)

**职责**: 股票列表显示、筛选、排序

**Treeview列结构**:
| 列名 | 说明 |
|------|------|
| Symbol | 股票代码 |
| Breakthroughs | 突破数量 |
| Active Peaks | 活跃峰值数 |
| Avg Quality | 平均质量分数 |
| Max Quality | 最高质量分数 |

**筛选功能**:
```python
def apply_filters(self, min_quality=0, min_breakthroughs=0, min_peaks=0)
    """应用筛选条件，更新Treeview显示"""
```

**排序功能**:
```python
def sort_by(self, column: str, reverse: bool = True)
    """按指定列排序（点击列头触发）"""
```

---

### 3.4 ParameterPanel (parameter_panel.py)

**职责**: 参数输入和控制按钮

**参数管理**:
```python
class ParameterPanel:
    def __init__(self, parent):
        # 参数变量
        self.window_var = tk.IntVar(value=5)
        self.threshold_var = tk.DoubleVar(value=0.005)

        # 绑定trace_add监听变化
        self.window_var.trace_add('write', self._on_param_changed)
        self.threshold_var.trace_add('write', self._on_param_changed)

        # 防抖定时器
        self._update_timer = None

    def _on_param_changed(self, *args):
        """参数变化回调（500ms防抖）"""
        if self._update_timer:
            self.root.after_cancel(self._update_timer)
        self._update_timer = self.root.after(500, self._notify_update)
```

**UI组件**:
- 加载按钮: 打开文件对话框选择JSON
- Window Spinbox: 范围3-20，步长1
- Threshold Spinbox: 范围0.001-0.02，步长0.001
- 刷新按钮: 强制刷新图表

---

### 3.5 ChartCanvasManager (chart_canvas_manager.py)

**职责**: 管理matplotlib图表的Canvas嵌入和更新

**关键实现**:
```python
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class ChartCanvasManager:
    def __init__(self, parent_container, plotter: BreakthroughPlotter):
        self.container = parent_container
        self.plotter = plotter  # 复用现有绘图器
        self.canvas = None
        self.fig = None

    def update_chart(self, df, breakthroughs, detector):
        """更新图表显示"""
        # 1. 清理旧图表（防内存泄漏）
        self._cleanup()

        # 2. 创建新图表（复用BreakthroughPlotter逻辑）
        import matplotlib.pyplot as plt
        self.fig = plt.Figure(figsize=(16, 10), dpi=100)
        axes = self.fig.subplots(3, 1, height_ratios=[3, 1, 0.3])
        ax_main, ax_volume, ax_stats = axes

        # 3. 调用现有组件绘图（完全复用）
        self.plotter.candlestick.draw(ax_main, df)
        self.plotter.marker.draw_peaks(ax_main, df, detector.active_peaks,
                                       quality_color_map=True)
        self.plotter.marker.draw_breakthroughs(ax_main, df, breakthroughs,
                                               highlight_multi_peak=True)
        self.plotter.marker.draw_resistance_zones(ax_main, df, breakthroughs,
                                                   alpha=0.15)

        breakthrough_dates = [df.index[bt.index] for bt in breakthroughs]
        self.plotter.candlestick.draw_volume(ax_volume, df,
                                             highlight_dates=breakthrough_dates)
        self.plotter.panel.draw_statistics_panel(ax_stats, breakthroughs)

        # 4. 嵌入Tkinter Canvas
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.container)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.canvas.draw()

        # 5. 绑定鼠标悬停事件
        self._attach_hover(df, breakthroughs)

    def _cleanup(self):
        """清理旧图表，防止内存泄漏"""
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
        if self.fig:
            import matplotlib.pyplot as plt
            plt.close(self.fig)
            self.fig = None

    def _attach_hover(self, df, breakthroughs):
        """绑定鼠标悬停事件"""
        def on_hover(event):
            if event.inaxes:
                # 计算最近的数据点
                x = int(round(event.xdata))
                if 0 <= x < len(df):
                    row = df.iloc[x]
                    info = f"Date: {df.index[x].strftime('%Y-%m-%d')}\n"
                    info += f"Close: ${row['close']:.2f}\n"
                    info += f"Volume: {row['volume']:,}"

                    # 检查是否是突破点
                    for bt in breakthroughs:
                        if bt.index == x:
                            info += f"\n★ Breakthrough (Q={bt.quality_score:.1f})"
                            break

                    # 显示tooltip（简化实现：打印到控制台）
                    print(info)

        self.canvas.mpl_connect('motion_notify_event', on_hover)
```

**内存管理验证**:
- 测试方法: 连续切换100只股票
- 验收标准: 内存增长 < 50MB

---

### 3.6 NavigationManager (navigation_manager.py)

**职责**: 处理键盘快捷键

**快捷键映射**:
| 快捷键 | 功能 |
|--------|------|
| ↑ (Up) | 上一只股票 |
| ↓ (Down) | 下一只股票 |
| Enter | 刷新当前图表 |

**实现要点**:
```python
class NavigationManager:
    def __init__(self, root, tree_widget, chart_update_callback):
        self.root = root
        self.tree = tree_widget
        self.chart_update_callback = chart_update_callback

        # 绑定全局键盘事件
        self.root.bind('<Up>', self._on_up)
        self.root.bind('<Down>', self._on_down)
        self.root.bind('<Return>', self._on_enter)

    def _on_up(self, event):
        """上键：选择上一个"""
        children = self.tree.get_children()
        sel = self.tree.selection()
        if sel:
            idx = list(children).index(sel[0])
            if idx > 0:
                new_target = children[idx - 1]
                self.tree.selection_set(new_target)
                self.tree.see(new_target)
                self.chart_update_callback()
        return "break"

    def _on_down(self, event):
        """下键：选择下一个"""
        # 类似实现...
```

**焦点保护**:
- 焦点在Spinbox时，不拦截上下键（允许Spinbox内部导航）
- 使用 `root.focus_get()` 判断当前焦点控件类型

---

## 四、数据流设计

### 批量扫描流程
```python
# batch_scan.py
from BreakthroughStrategy.visualization.interactive import ScanManager

def main():
    # 1. 获取所有股票代码
    import os
    symbols = [f[:-4] for f in os.listdir('datasets/pkls') if f.endswith('.pkl')]

    # 2. 创建扫描管理器
    manager = ScanManager(output_dir='scan_results')

    # 3. 并行扫描（8进程）
    results = manager.parallel_scan(symbols, num_workers=8)

    # 4. 保存结果
    manager.save_results(results, 'scan_results/full_scan.json')

    print(f"扫描完成: {len(results)}只股票")
```

### 交互式查看流程
```python
# interactive_viewer.py
import tkinter as tk
import matplotlib
matplotlib.use('TkAgg')  # 切换到交互式后端

from BreakthroughStrategy.visualization.interactive import InteractiveUI

def main():
    root = tk.Tk()
    app = InteractiveUI(root)

    # 自动加载最新扫描结果（可选）
    # app.load_scan_results('scan_results/full_scan.json')

    root.mainloop()

if __name__ == '__main__':
    main()
```

### 实时参数调整流程
```
用户调整Spinbox → trace_add触发 → 500ms防抖 → 回调执行:
  1. 获取当前选中股票
  2. 读取PKL数据（LRU缓存）
  3. 重新运行BreakthroughDetector（新参数）
  4. 调用ChartCanvasManager.update_chart()
  5. 刷新Canvas显示
```

---

## 五、技术细节

### 5.1 Matplotlib后端管理

**问题**: visual_demo.py使用Agg后端（静态），交互式UI需要TkAgg后端

**解决方案**:
```python
# interactive_viewer.py（交互式启动脚本）
import matplotlib
matplotlib.use('TkAgg')  # 必须在import pyplot之前
import matplotlib.pyplot as plt

# visual_demo.py（静态脚本，不修改）
# 默认使用Agg后端，或显式设置matplotlib.use('Agg')
```

**注意**: 后端设置必须在程序入口，导入matplotlib后无法切换

---

### 5.2 内存泄漏防护

**关键措施**:
1. 每次更新前调用 `_cleanup()`
2. 销毁Canvas widget: `canvas.get_tk_widget().destroy()`
3. 关闭Figure: `plt.close(fig)`
4. 清空引用: `self.fig = None`

**测试方法**:
```python
import psutil
import os

process = psutil.Process(os.getpid())
initial_memory = process.memory_info().rss / 1024 / 1024  # MB

for i in range(100):
    app.on_stock_selected(f'STOCK_{i % 10}')  # 切换10只股票，循环10次

final_memory = process.memory_info().rss / 1024 / 1024
print(f"内存增长: {final_memory - initial_memory:.2f} MB")

# 验收标准: < 50MB
```

---

### 5.3 性能优化

**LRU缓存**:
```python
from functools import lru_cache

@lru_cache(maxsize=10)
def _load_stock_data(symbol):
    """缓存最近10只股票的数据"""
    return pd.read_pickle(f'datasets/pkls/{symbol}.pkl')
```

**异步加载**（可选）:
```python
def _async_load_and_update(self, symbol):
    """在后台线程加载数据"""
    def _load():
        df = pd.read_pickle(f'datasets/pkls/{symbol}.pkl')
        # 使用root.after()回调到主线程更新UI
        self.root.after(0, lambda: self._update_chart(df))

    threading.Thread(target=_load, daemon=True).start()
```

---

### 5.4 鼠标悬停实现

**方案A: 简化版（打印到控制台）**:
```python
def on_hover(event):
    if event.inaxes and event.xdata is not None:
        x = int(round(event.xdata))
        if 0 <= x < len(df):
            row = df.iloc[x]
            print(f"Date: {df.index[x]}, Close: {row['close']:.2f}")
```

**方案B: Tooltip弹窗（推荐）**:
```python
# 使用matplotlib的Annotation
self.annotation = ax.annotate("", xy=(0,0), xytext=(20,20),
                             textcoords="offset points",
                             bbox=dict(boxstyle="round", fc="w"),
                             arrowprops=dict(arrowstyle="->"))
self.annotation.set_visible(False)

def on_hover(event):
    if event.inaxes:
        x = int(round(event.xdata))
        if 0 <= x < len(df):
            row = df.iloc[x]
            text = f"Date: {df.index[x].strftime('%Y-%m-%d')}\n"
            text += f"Close: ${row['close']:.2f}"

            self.annotation.xy = (x, row['close'])
            self.annotation.set_text(text)
            self.annotation.set_visible(True)
            self.canvas.draw_idle()
```

---

## 六、实施步骤

### 阶段一: 扫描系统（2天）

**任务**:
1. 创建 `BreakthroughStrategy/visualization/interactive/` 目录
2. 实现 `scan_manager.py`:
   - `ScanManager` 类
   - `scan_stock()` 方法（单股票扫描）
   - `parallel_scan()` 方法（multiprocessing.Pool）
   - `save_results()` 和 `load_results()` 方法
3. 创建 `scripts/batch_scan.py` 启动脚本
4. 测试: 扫描100只股票验证正确性

**验收标准**:
- ✅ 扫描100只股票成功，生成JSON
- ✅ JSON格式符合设计（包含metadata和results数组）
- ✅ 错误股票不中断整体扫描（记录到error字段）
- ✅ 支持断点恢复（每100只保存checkpoint）

---

### 阶段二: 基础UI（2天）

**任务**:
1. 实现 `interactive_ui.py`:
   - `InteractiveUI` 主窗口类
   - 布局创建（PanedWindow分割）
   - `load_scan_results()` 方法
2. 实现 `stock_list_panel.py`:
   - `StockListPanel` 类
   - Treeview创建和数据填充
   - 点击事件绑定
3. 实现 `chart_canvas_manager.py`:
   - `ChartCanvasManager` 类
   - `update_chart()` 方法（复用BreakthroughPlotter）
   - `_cleanup()` 防内存泄漏
4. 创建 `scripts/interactive_viewer.py` 启动脚本

**验收标准**:
- ✅ 可加载JSON文件并显示股票列表
- ✅ 点击股票显示图表
- ✅ 图表质量与 `visual_demo.py` 一致
- ✅ 复用所有现有组件（CandlestickComponent等）

---

### 阶段三: 交互增强（1.5天）

**任务**:
1. 实现 `parameter_panel.py`:
   - `ParameterPanel` 类
   - Spinbox创建和trace_add绑定
   - 防抖机制（500ms）
2. 添加实时参数调整功能:
   - 参数变化 → 重新检测 → 刷新图表
   - 加载按钮和刷新按钮
3. 添加筛选和排序功能:
   - `StockListPanel.apply_filters()`
   - `StockListPanel.sort_by()`
   - Treeview列头点击排序
4. 添加鼠标悬停功能:
   - `ChartCanvasManager._attach_hover()`
   - Annotation显示详细数据

**验收标准**:
- ✅ 参数调整后500ms刷新图表
- ✅ 刷新流畅无卡顿（图表生成 < 1s）
- ✅ 筛选功能正常（最小质量、最小突破数）
- ✅ 排序功能正常（点击列头排序）
- ✅ 鼠标悬停显示详细数据

---

### 阶段四: 导航优化和测试（0.5天）

**任务**:
1. 实现 `navigation_manager.py`:
   - `NavigationManager` 类
   - 键盘快捷键绑定（↑/↓/Enter）
   - 焦点保护逻辑
2. 内存泄漏测试:
   - 连续切换100只股票
   - 验证内存增长 < 50MB
3. 性能优化:
   - LRU缓存实现
   - 防抖时间微调
4. 文档更新:
   - 更新 `docs/modules/summaries/11_可视化模块总结.md`
   - 添加交互式UI使用说明

**验收标准**:
- ✅ 键盘导航正常工作
- ✅ 内存测试通过（< 50MB增长）
- ✅ 图表刷新性能达标（< 1s）
- ✅ 文档更新完成

---

## 七、关键文件清单

### 需要创建的文件

| 文件路径 | 说明 | 行数 |
|---------|------|------|
| `BreakthroughStrategy/visualization/interactive/__init__.py` | 模块导出 | 10 |
| `BreakthroughStrategy/visualization/interactive/scan_manager.py` | 扫描管理器 | 200 |
| `BreakthroughStrategy/visualization/interactive/interactive_ui.py` | 主窗口 | 300 |
| `BreakthroughStrategy/visualization/interactive/stock_list_panel.py` | 股票列表 | 200 |
| `BreakthroughStrategy/visualization/interactive/parameter_panel.py` | 参数面板 | 100 |
| `BreakthroughStrategy/visualization/interactive/chart_canvas_manager.py` | 图表管理 | 150 |
| `BreakthroughStrategy/visualization/interactive/navigation_manager.py` | 键盘导航 | 80 |
| `BreakthroughStrategy/visualization/interactive/utils.py` | 工具函数 | 50 |
| `scripts/batch_scan.py` | 扫描脚本 | 80 |
| `scripts/interactive_viewer.py` | 启动脚本 | 50 |
| **总计** | | **~1220行** |

### 需要读取的关键文件

实施时需要参考以下文件：

1. **`BreakthroughStrategy/visualization/plotters/breakthrough_plotter.py`**
   - 复用其组件调用逻辑（candlestick, marker, panel）
   - 参考 `plot_full_analysis()` 方法的绘图流程

2. **`BreakthroughStrategy/analysis/breakthrough_detector.py`**
   - 理解 `batch_add_bars()` 的使用方法
   - 参考 `active_peaks` 数据结构

3. **`scripts/visual_demo.py`**
   - 参考完整的数据加载 → 检测 → 绘图流程
   - 参考特征计算和质量评分的调用方式

4. **`BreakthroughStrategy/analysis/features.py`**
   - 理解 `FeatureCalculator.enrich_breakthrough()` 方法

5. **`BreakthroughStrategy/analysis/quality_scorer.py`**
   - 理解 `QualityScorer.score_breakthroughs_batch()` 方法

### 不修改的文件

以下文件完全不修改，仅作为依赖使用：
- `BreakthroughStrategy/visualization/components/*.py` (所有组件)
- `BreakthroughStrategy/visualization/plotters/*.py` (所有绘图器)
- `scripts/visual_demo.py` (静态演示脚本)

---

## 八、风险与缓解措施

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **内存泄漏** | 高 | 高 | 每次更新前调用`_cleanup()`，测试验证 |
| **并行扫描错误** | 中 | 中 | 捕获异常，记录到error字段，不中断整体扫描 |
| **性能卡顿** | 中 | 中 | 防抖500ms + LRU缓存 + 异步加载 |
| **PKL文件损坏** | 低 | 中 | 扫描时try-except，跳过损坏文件 |
| **Tkinter线程冲突** | 高 | 低 | 所有UI操作在主线程，数据加载用`root.after()` |
| **后端切换失败** | 高 | 低 | 在程序入口设置，避免运行时切换 |

---

## 九、工作量估算

### 总工作量: 4-5人天

| 阶段 | 任务 | 工时 |
|------|------|------|
| 阶段一 | 扫描系统开发 | 16小时 |
| 阶段二 | 基础UI开发 | 16小时 |
| 阶段三 | 交互增强 | 12小时 |
| 阶段四 | 导航优化和测试 | 4小时 |
| **总计** | | **48小时 ≈ 6工作日** |

考虑到调试和测试时间，预留缓冲为 **4-5人天**。

---

## 十、验收标准总结

### 功能验收
- ✅ 批量扫描10855只股票，生成JSON结果
- ✅ 交互式UI可加载JSON并显示股票列表
- ✅ 点击股票显示完整分析图（与静态模式质量一致）
- ✅ 参数实时调整（Spinbox + 500ms防抖）
- ✅ 键盘导航（↑/↓切换股票）
- ✅ 鼠标悬停显示详细数据
- ✅ 筛选和排序功能正常

### 性能验收
- ✅ 扫描性能: 10855只股票 < 10分钟（8进程并行）
- ✅ 图表刷新: < 1秒
- ✅ 内存管理: 连续切换100次，内存增长 < 50MB

### 代码质量
- ✅ 完全复用现有组件（CandlestickComponent等）
- ✅ 不修改现有可视化模块代码
- ✅ 保留visual_demo.py和静态图片生成能力
- ✅ 代码符合项目结构规范

---

## 附录: 快速启动指南

### 批量扫描
```bash
# 扫描所有股票
python scripts/batch_scan.py

# 输出: scan_results/full_scan_20251126.json
```

### 交互式查看
```bash
# 启动交互式查看器
python scripts/interactive_viewer.py

# 操作:
# 1. 点击"加载结果"按钮，选择JSON文件
# 2. 股票列表显示所有结果
# 3. 点击股票查看图表
# 4. 调整参数观察变化
# 5. 使用↑/↓键导航
```

---

**实施方案结束**
