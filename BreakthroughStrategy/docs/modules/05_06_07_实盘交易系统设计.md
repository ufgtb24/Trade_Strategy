# 实盘交易系统设计文档（监测+交易+风险管理）

**模块路径**：`BreakthroughStrategy/monitoring/`, `trading/`, `risk/`
**创建日期**：2025-11-16

---

## 一、模块概述

实盘交易系统包含三个紧密耦合的子系统：
1. **监测系统**：实时监控观察池，检测买入信号
2. **交易执行**：通过Tiger API执行买卖操作
3. **风险管理**：止盈止损、仓位管理

**核心流程**：监测买入信号 → 下单买入 → 持仓管理 → 止盈/止损卖出

**依赖**：
- `observation`：观察池管理
- `data`：实时行情订阅
- `config`：交易参数
- `utils.database`：订单/持仓记录

---

## 二、模块架构

```
BreakthroughStrategy/
├── monitoring/               # 监测系统
│   ├── __init__.py
│   ├── realtime_monitor.py  # RealtimeMonitor - 实时监控
│   ├── signal_detector.py   # SignalDetector - 信号检测
│   └── scheduler.py          # MonitorScheduler - 监控调度
├── trading/                  # 交易执行
│   ├── __init__.py
│   ├── tiger_trader.py      # TigerTrader - Tiger API交易
│   ├── order_manager.py     # OrderManager - 订单管理
│   └── position_tracker.py  # PositionTracker - 持仓追踪
└── risk/                     # 风险管理
    ├── __init__.py
    ├── stop_loss_manager.py  # StopLossManager - 止损管理
    ├── take_profit_manager.py # TakeProfitManager - 止盈管理
    └── position_sizer.py     # PositionSizer - 仓位管理
```

---

## 三、监测系统

### 3.1 SignalDetector（信号检测）

#### 3.1.1 买入信号逻辑

```python
from typing import Optional, Dict
import pandas as pd

class SignalDetector:
    """买入信号检测器"""

    def __init__(self, config=None):
        """初始化信号检测器"""
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.realtime_threshold_pct = cfg.get('price.realtime_buy_threshold_pct', 0.02)
            self.daily_signal_threshold = cfg.get('price.daily_buy_signal_threshold', 70)
        else:
            self.realtime_threshold_pct = config.get('realtime_threshold_pct', 0.02)
            self.daily_signal_threshold = config.get('daily_signal_threshold', 70)

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('monitoring.signal')

    def detect_realtime_signal(
        self,
        current_price: float,
        breakthrough_info: Dict
    ) -> bool:
        """
        实时买入信号检测（适用于实时观察池）

        信号条件：
        当前价格 > 突破日K线实体上沿 × (1 + threshold_pct)

        Args:
            current_price: 当前价格
            breakthrough_info: 突破信息字典

        Returns:
            是否触发买入信号
        """
        # 获取突破日K线实体上沿
        # 假设breakthrough_info包含breakthrough_price（突破日最高价）
        # 实际应该包含open, close，取max作为实体上沿
        breakthrough_price = breakthrough_info.get('price')

        # 简化版：使用突破价格
        trigger_price = breakthrough_price * (1 + self.realtime_threshold_pct)

        signal = current_price >= trigger_price

        if signal:
            self.logger.info(f"Realtime buy signal: price ${current_price:.2f} >= trigger ${trigger_price:.2f}")

        return signal

    def detect_daily_signal(
        self,
        symbol: str,
        recent_data: pd.DataFrame,
        peak_price: float
    ) -> bool:
        """
        日K买入信号检测（适用于日K观察池）

        信号条件（综合判断）：
        1. 企稳：最低价 > 凸点价格 × 0.98
        2. 走强：阳线 + 放量 或 突破短期MA

        Args:
            symbol: 股票代码
            recent_data: 最近N天的日K数据
            peak_price: 凸点价格

        Returns:
            是否触发买入信号
        """
        if recent_data.empty or len(recent_data) < 3:
            return False

        latest = recent_data.iloc[-1]
        prev = recent_data.iloc[-2]

        # 1. 企稳判断
        stabilized = latest['low'] >= peak_price * 0.98

        if not stabilized:
            return False

        # 2. 走强判断
        # 条件A：阳线 + 放量
        is_green_candle = latest['close'] > latest['open']

        # 计算相对成交量
        avg_volume = recent_data['volume'].iloc[-10:].mean()
        volume_surge = latest['volume'] / avg_volume if avg_volume > 0 else 1.0

        signal_a = is_green_candle and volume_surge > 1.5

        # 条件B：突破5日MA
        if len(recent_data) >= 5:
            ma5 = recent_data['close'].iloc[-5:].mean()
            signal_b = latest['close'] > ma5 and prev['close'] <= ma5
        else:
            signal_b = False

        signal = signal_a or signal_b

        if signal:
            self.logger.info(f"{symbol}: Daily buy signal (stabilized + strong)")

        return signal
```

### 3.2 RealtimeMonitor（实时监控）

```python
from typing import List, Dict, Callable
from datetime import datetime

class RealtimeMonitor:
    """实时行情监控器"""

    def __init__(self):
        """初始化实时监控器"""
        from BreakthroughStrategy.data import DataManager
        from BreakthroughStrategy.observation import PoolManager

        self.data_manager = DataManager()
        self.pool_manager = PoolManager()
        self.signal_detector = SignalDetector()

        # 回调函数（触发买入信号时调用）
        self.buy_signal_callback: Optional[Callable] = None

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('monitoring.realtime')

    def start(self, buy_signal_callback: Callable):
        """
        启动实时监控

        Args:
            buy_signal_callback: 买入信号回调函数 callback(symbol, entry_info, current_price)
        """
        self.buy_signal_callback = buy_signal_callback

        # 获取实时观察池中的股票
        active_symbols = [
            e.symbol for e in self.pool_manager.realtime_pool.get_all('active')
        ]

        if not active_symbols:
            self.logger.info("No symbols in realtime pool, monitoring stopped")
            return

        self.logger.info(f"Starting realtime monitoring for {len(active_symbols)} symbols")

        # 订阅实时行情
        self.data_manager.subscribe_realtime(active_symbols, self._on_quote_update)

    def _on_quote_update(self, quote_data: Dict):
        """
        实时行情更新回调

        Args:
            quote_data: 行情数据字典 {symbol, latest_price, latest_time, ...}
        """
        symbol = quote_data['symbol']
        current_price = quote_data['latest_price']

        # 获取观察池条目
        entry = self.pool_manager.realtime_pool.get_by_symbol(symbol)
        if not entry or entry.status != 'active':
            return

        # 检测买入信号
        signal = self.signal_detector.detect_realtime_signal(
            current_price,
            entry.breakthrough_info
        )

        if signal:
            # 触发买入信号回调
            if self.buy_signal_callback:
                self.buy_signal_callback(symbol, entry, current_price)

            # 更新观察池状态
            self.pool_manager.realtime_pool.update_status(symbol, 'bought')

    def stop(self):
        """停止监控"""
        # 断开WebSocket连接
        self.data_manager.stream.disconnect()
        self.logger.info("Realtime monitoring stopped")
```

### 3.3 MonitorScheduler（监控调度）

```python
import schedule
import time
from datetime import datetime

class MonitorScheduler:
    """监控调度器"""

    def __init__(self):
        """初始化调度器"""
        from BreakthroughStrategy.observation import PoolManager
        from BreakthroughStrategy.data import DataManager

        self.pool_manager = PoolManager()
        self.data_manager = DataManager()
        self.signal_detector = SignalDetector()

        # 回调
        self.buy_signal_callback: Optional[Callable] = None

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('monitoring.scheduler')

    def start(self, buy_signal_callback: Callable):
        """启动调度器"""
        self.buy_signal_callback = buy_signal_callback

        # 设置定时任务
        # 每日开盘前：检查日K观察池
        schedule.every().day.at("09:00").do(self.check_daily_pool)

        # 每日收盘后：维护观察池
        schedule.every().day.at("17:00").do(self.pool_maintenance)

        self.logger.info("Monitor scheduler started")

        # 运行循环
        while True:
            schedule.run_pending()
            time.sleep(60)

    def check_daily_pool(self):
        """检查日K观察池中的股票"""
        self.logger.info("Checking daily pool for buy signals")

        active_entries = self.pool_manager.daily_pool.get_all('active')

        for entry in active_entries:
            try:
                # 获取最近10天的数据
                df = self.data_manager.get_historical_data(
                    entry.symbol,
                    (datetime.now() - timedelta(days=15)).strftime('%Y-%m-%d'),
                    datetime.now().strftime('%Y-%m-%d')
                )

                if df.empty:
                    continue

                # 检测买入信号
                signal = self.signal_detector.detect_daily_signal(
                    entry.symbol,
                    df,
                    entry.peak_info.get('price')
                )

                if signal:
                    # 获取当前价格（最新收盘价）
                    current_price = df.iloc[-1]['close']

                    # 触发买入
                    if self.buy_signal_callback:
                        self.buy_signal_callback(entry.symbol, entry, current_price)

                    # 更新状态
                    self.pool_manager.daily_pool.update_status(entry.symbol, 'bought')

            except Exception as e:
                self.logger.error(f"Failed to check {entry.symbol}: {e}")

    def pool_maintenance(self):
        """观察池维护"""
        self.pool_manager.move_timeout_to_daily_pool()
        self.pool_manager.cleanup_expired()
```

---

## 四、交易执行

### 4.1 TigerTrader（Tiger API交易）

```python
from tigeropen.trade.trade_client import TradeClient
from tigeropen.common.consts import OrderType, Market

class TigerTrader:
    """Tiger API交易接口"""

    def __init__(self, config=None):
        """初始化Tiger交易客户端"""
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            credentials = cfg.get_section('api')['credentials']
        else:
            credentials = config

        # 初始化Trade Client
        client_config = TigerOpenClientConfig(
            tiger_id=credentials['tiger_id'],
            account=credentials['account'],
            private_key_path=credentials['private_key_path']
        )
        self.trade_client = TradeClient(client_config)

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('trading.tiger')

    def place_market_order(
        self,
        symbol: str,
        quantity: int,
        action: str  # 'BUY' or 'SELL'
    ) -> Optional[str]:
        """
        下市价单

        Args:
            symbol: 股票代码
            quantity: 数量
            action: 'BUY' 或 'SELL'

        Returns:
            订单ID或None（失败）
        """
        try:
            contract = self.trade_client.get_contracts([symbol])[0]

            order = self.trade_client.create_order(
                contract=contract,
                action=action,
                order_type=OrderType.MKT,
                quantity=quantity
            )

            order_id = self.trade_client.place_order(order)

            self.logger.info(f"Placed {action} market order: {symbol} x {quantity}, order_id: {order_id}")
            return order_id

        except Exception as e:
            self.logger.error(f"Failed to place order for {symbol}: {e}")
            return None

    def place_limit_order(
        self,
        symbol: str,
        quantity: int,
        price: float,
        action: str
    ) -> Optional[str]:
        """下限价单"""
        try:
            contract = self.trade_client.get_contracts([symbol])[0]

            order = self.trade_client.create_order(
                contract=contract,
                action=action,
                order_type=OrderType.LMT,
                quantity=quantity,
                limit_price=price
            )

            order_id = self.trade_client.place_order(order)

            self.logger.info(f"Placed {action} limit order: {symbol} x {quantity} @ ${price:.2f}, order_id: {order_id}")
            return order_id

        except Exception as e:
            self.logger.error(f"Failed to place limit order for {symbol}: {e}")
            return None

    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        try:
            self.trade_client.cancel_order(order_id)
            self.logger.info(f"Cancelled order: {order_id}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to cancel order {order_id}: {e}")
            return False

    def get_order_status(self, order_id: str) -> Optional[Dict]:
        """查询订单状态"""
        try:
            order = self.trade_client.get_order(order_id)
            return {
                'order_id': order.id,
                'symbol': order.contract.symbol,
                'status': order.status,
                'filled_quantity': order.filled,
                'avg_fill_price': order.avg_fill_price
            }
        except Exception as e:
            self.logger.error(f"Failed to get order status {order_id}: {e}")
            return None

    def get_positions(self) -> List[Dict]:
        """获取当前持仓"""
        try:
            positions = self.trade_client.get_positions()
            return [{
                'symbol': pos.contract.symbol,
                'quantity': pos.quantity,
                'avg_cost': pos.average_cost,
                'market_value': pos.market_value,
                'unrealized_pnl': pos.unrealized_pnl
            } for pos in positions]
        except Exception as e:
            self.logger.error(f"Failed to get positions: {e}")
            return []
```

### 4.2 OrderManager（订单管理）

```python
class OrderManager:
    """订单管理器"""

    def __init__(self, db_manager=None):
        """初始化订单管理器"""
        if db_manager is None:
            from BreakthroughStrategy.utils.database import DatabaseManager
            self.db = DatabaseManager.get_instance()
        else:
            self.db = db_manager

        self.tiger_trader = TigerTrader()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('trading.order_manager')

    def create_buy_order(
        self,
        symbol: str,
        quantity: int,
        price: Optional[float] = None,
        order_type: str = 'market'
    ) -> Optional[str]:
        """
        创建买入订单

        Args:
            symbol: 股票代码
            quantity: 数量
            price: 限价（限价单）
            order_type: 'market' 或 'limit'

        Returns:
            订单ID
        """
        # 下单
        if order_type == 'market':
            order_id = self.tiger_trader.place_market_order(symbol, quantity, 'BUY')
        else:
            order_id = self.tiger_trader.place_limit_order(symbol, quantity, price, 'BUY')

        if not order_id:
            return None

        # 记录到数据库
        self.db.insert('orders', {
            'order_id': order_id,
            'symbol': symbol,
            'order_type': 'buy',
            'price_type': order_type,
            'quantity': quantity,
            'price': price,
            'status': 'submitted',
            'submit_time': datetime.now().isoformat()
        })

        return order_id

    def create_sell_order(
        self,
        symbol: str,
        quantity: int,
        price: Optional[float] = None,
        order_type: str = 'market'
    ) -> Optional[str]:
        """创建卖出订单"""
        # 下单
        if order_type == 'market':
            order_id = self.tiger_trader.place_market_order(symbol, quantity, 'SELL')
        else:
            order_id = self.tiger_trader.place_limit_order(symbol, quantity, price, 'SELL')

        if not order_id:
            return None

        # 记录到数据库
        self.db.insert('orders', {
            'order_id': order_id,
            'symbol': symbol,
            'order_type': 'sell',
            'price_type': order_type,
            'quantity': quantity,
            'price': price,
            'status': 'submitted',
            'submit_time': datetime.now().isoformat()
        })

        return order_id

    def update_order_status(self, order_id: str):
        """更新订单状态"""
        status_info = self.tiger_trader.get_order_status(order_id)

        if status_info:
            self.db.update('orders', {
                'status': status_info['status'],
                'filled_quantity': status_info['filled_quantity'],
                'filled_avg_price': status_info['avg_fill_price'],
                'updated_at': datetime.now().isoformat()
            }, {'order_id': order_id})
```

### 4.3 PositionTracker（持仓追踪）

```python
class PositionTracker:
    """持仓追踪器"""

    def __init__(self, db_manager=None):
        """初始化持仓追踪器"""
        if db_manager is None:
            from BreakthroughStrategy.utils.database import DatabaseManager
            self.db = DatabaseManager.get_instance()
        else:
            self.db = db_manager

        self.tiger_trader = TigerTrader()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('trading.position_tracker')

    def add_position(
        self,
        symbol: str,
        quantity: int,
        avg_cost: float,
        buy_order_id: str
    ):
        """添加持仓记录"""
        self.db.insert('positions', {
            'symbol': symbol,
            'quantity': quantity,
            'avg_cost': avg_cost,
            'buy_order_id': buy_order_id,
            'buy_time': datetime.now().isoformat()
        })

        self.logger.info(f"Added position: {symbol} x {quantity} @ ${avg_cost:.2f}")

    def update_positions(self):
        """更新所有持仓的当前价格和盈亏"""
        positions = self.db.query("SELECT * FROM positions")

        for pos in positions:
            symbol = pos['symbol']

            # 获取当前价格
            quote = self.tiger_trader.trade_client.get_quote([symbol])[0]
            current_price = quote.latest_price

            # 计算未实现盈亏
            unrealized_pnl = (current_price - pos['avg_cost']) * pos['quantity']

            # 更新数据库
            self.db.update('positions', {
                'current_price': current_price,
                'unrealized_pnl': unrealized_pnl,
                'updated_at': datetime.now().isoformat()
            }, {'symbol': symbol})

    def get_position(self, symbol: str) -> Optional[Dict]:
        """获取持仓"""
        rows = self.db.query("SELECT * FROM positions WHERE symbol = ?", (symbol,))
        if rows:
            return rows[0]
        return None

    def remove_position(self, symbol: str):
        """移除持仓"""
        self.db.delete('positions', {'symbol': symbol})
        self.logger.info(f"Removed position: {symbol}")
```

---

## 五、风险管理

### 5.1 StopLossManager（止损管理）

```python
class StopLossManager:
    """止损管理器"""

    def __init__(self, config=None):
        """初始化止损管理器"""
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.stop_loss_pct = cfg.get('risk.stop_loss_pct', 0.05)
            self.trailing_stop_pct = cfg.get('risk.trailing_stop_pct', 0.03)
        else:
            self.stop_loss_pct = config.get('stop_loss_pct', 0.05)
            self.trailing_stop_pct = config.get('trailing_stop_pct', 0.03)

        self.position_tracker = PositionTracker()
        self.order_manager = OrderManager()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('risk.stop_loss')

    def check_stop_loss(self, symbol: str, current_price: float) -> bool:
        """
        检查固定止损

        Args:
            symbol: 股票代码
            current_price: 当前价格

        Returns:
            是否触发止损
        """
        position = self.position_tracker.get_position(symbol)
        if not position:
            return False

        stop_loss_price = position['avg_cost'] * (1 - self.stop_loss_pct)

        if current_price <= stop_loss_price:
            self.logger.warning(f"{symbol} hit stop loss: ${current_price:.2f} <= ${stop_loss_price:.2f}")
            self._execute_stop_loss(symbol, position['quantity'], 'fixed_stop_loss')
            return True

        return False

    def check_trailing_stop(self, symbol: str, current_price: float) -> bool:
        """
        检查移动止损

        逻辑：
        1. 获取持仓期间最高价
        2. 计算trailing_stop_price = max_price * (1 - trailing_stop_pct)
        3. 如果current_price <= trailing_stop_price，触发止损
        """
        position = self.position_tracker.get_position(symbol)
        if not position:
            return False

        # 更新最高价（需要在position表中维护max_price字段）
        max_price = position.get('max_price', position['avg_cost'])
        if current_price > max_price:
            max_price = current_price
            # 更新数据库
            self.position_tracker.db.update('positions', {'max_price': max_price}, {'symbol': symbol})

        trailing_stop_price = max_price * (1 - self.trailing_stop_pct)

        if current_price <= trailing_stop_price:
            self.logger.warning(f"{symbol} hit trailing stop: ${current_price:.2f} <= ${trailing_stop_price:.2f}")
            self._execute_stop_loss(symbol, position['quantity'], 'trailing_stop')
            return True

        return False

    def _execute_stop_loss(self, symbol: str, quantity: int, reason: str):
        """执行止损卖出"""
        # 市价卖出
        order_id = self.order_manager.create_sell_order(symbol, quantity, order_type='market')

        if order_id:
            self.logger.info(f"Stop loss executed: {symbol}, reason: {reason}")

            # 移除持仓
            self.position_tracker.remove_position(symbol)

            # 循环跟踪：重新加入观察池
            # （在实际实现中，应该通过回调通知observation模块）
```

### 5.2 TakeProfitManager（止盈管理）

```python
class TakeProfitManager:
    """止盈管理器"""

    def __init__(self, config=None):
        """初始化止盈管理器"""
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.target_profit_pct = cfg.get('risk.target_profit_pct', 0.15)
        else:
            self.target_profit_pct = config.get('target_profit_pct', 0.15)

        self.position_tracker = PositionTracker()
        self.order_manager = OrderManager()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('risk.take_profit')

    def check_take_profit(self, symbol: str, current_price: float) -> bool:
        """检查目标止盈"""
        position = self.position_tracker.get_position(symbol)
        if not position:
            return False

        target_price = position['avg_cost'] * (1 + self.target_profit_pct)

        if current_price >= target_price:
            self.logger.info(f"{symbol} hit take profit target: ${current_price:.2f} >= ${target_price:.2f}")
            self._execute_take_profit(symbol, position['quantity'])
            return True

        return False

    def _execute_take_profit(self, symbol: str, quantity: int):
        """执行止盈卖出"""
        order_id = self.order_manager.create_sell_order(symbol, quantity, order_type='market')

        if order_id:
            self.logger.info(f"Take profit executed: {symbol}")
            self.position_tracker.remove_position(symbol)
```

### 5.3 PositionSizer（仓位管理）

```python
class PositionSizer:
    """仓位管理器"""

    def __init__(self, config=None):
        """初始化仓位管理器"""
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.max_position_size_pct = cfg.get('risk.max_position_size_pct', 0.10)
            self.max_holdings = cfg.get('risk.max_holdings', 10)
        else:
            self.max_position_size_pct = config.get('max_position_size_pct', 0.10)
            self.max_holdings = config.get('max_holdings', 10)

        self.position_tracker = PositionTracker()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('risk.position_sizer')

    def calculate_quantity(self, symbol: str, price: float, total_capital: float) -> int:
        """
        计算买入数量

        Args:
            symbol: 股票代码
            price: 买入价格
            total_capital: 总资金

        Returns:
            买入数量
        """
        # 检查持仓数量是否已达上限
        current_holdings = len(self.position_tracker.db.query("SELECT * FROM positions"))

        if current_holdings >= self.max_holdings:
            self.logger.warning(f"Max holdings reached: {current_holdings}/{self.max_holdings}")
            return 0

        # 计算仓位大小
        position_value = total_capital * self.max_position_size_pct
        quantity = int(position_value / price)

        self.logger.info(f"{symbol}: calculated quantity = {quantity} (price: ${price:.2f}, capital: ${total_capital:.2f})")

        return quantity
```

---

## 六、完整交易流程

```python
from BreakthroughStrategy.monitoring import RealtimeMonitor, MonitorScheduler
from BreakthroughStrategy.trading import OrderManager, PositionTracker
from BreakthroughStrategy.risk import StopLossManager, TakeProfitManager, PositionSizer

class TradingSystem:
    """完整交易系统"""

    def __init__(self):
        """初始化交易系统"""
        # 监测
        self.realtime_monitor = RealtimeMonitor()
        self.scheduler = MonitorScheduler()

        # 交易
        self.order_manager = OrderManager()
        self.position_tracker = PositionTracker()

        # 风险管理
        self.stop_loss_manager = StopLossManager()
        self.take_profit_manager = TakeProfitManager()
        self.position_sizer = PositionSizer()

        from BreakthroughStrategy.utils.logger import Logger
        self.logger = Logger.get_logger('trading.system')

    def start(self, total_capital: float):
        """启动交易系统"""
        self.total_capital = total_capital

        # 启动实时监控
        self.realtime_monitor.start(buy_signal_callback=self.on_buy_signal)

        # 启动调度器
        self.scheduler.start(buy_signal_callback=self.on_buy_signal)

        self.logger.info(f"Trading system started with capital: ${total_capital:.2f}")

    def on_buy_signal(self, symbol: str, entry_info, current_price: float):
        """买入信号回调"""
        self.logger.info(f"Buy signal triggered: {symbol} @ ${current_price:.2f}")

        # 计算买入数量
        quantity = self.position_sizer.calculate_quantity(symbol, current_price, self.total_capital)

        if quantity == 0:
            self.logger.warning(f"{symbol}: skipped (quantity = 0)")
            return

        # 下市价买单
        order_id = self.order_manager.create_buy_order(symbol, quantity, order_type='market')

        if order_id:
            # 等待成交（简化版：假设立即成交）
            # 实际应该轮询订单状态

            # 添加持仓
            self.position_tracker.add_position(symbol, quantity, current_price, order_id)

            self.logger.info(f"Bought {symbol}: {quantity} shares @ ${current_price:.2f}")

    def check_risk_management(self):
        """检查风险管理（定期调用）"""
        positions = self.position_tracker.db.query("SELECT * FROM positions")

        for pos in positions:
            symbol = pos['symbol']

            # 获取当前价格
            from BreakthroughStrategy.data import DataManager
            dm = DataManager()
            quote = dm.tiger.get_realtime_quote(symbol)
            current_price = quote['latest_price']

            # 检查止损
            if self.stop_loss_manager.check_stop_loss(symbol, current_price):
                continue

            if self.stop_loss_manager.check_trailing_stop(symbol, current_price):
                continue

            # 检查止盈
            if self.take_profit_manager.check_take_profit(symbol, current_price):
                continue
```

---

## 七、使用示例

```python
# 启动完整交易系统
system = TradingSystem()
system.start(total_capital=100000)  # $100,000

# 系统将自动：
# 1. 监控观察池
# 2. 检测买入信号
# 3. 执行买入
# 4. 管理持仓（止盈止损）
```

---

**文档状态**：初稿完成
**所有10份设计文档已完成！**
