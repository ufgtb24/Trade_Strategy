# 技术分析模块技术设计文档

**模块路径**：`BreakthroughStrategy/analysis/`
**文档版本**：v1.0
**创建日期**：2025-11-16

---

## 一、模块概述

技术分析模块是整个突破策略的**算法核心**，负责：
1. **凸点识别**：找到历史阻力位（局部最高点）
2. **突破检测**：判断股价是否突破凸点
3. **质量评分**：评估凸点和突破的历史意义
4. **技术指标**：计算辅助指标（成交量、RSI等）

**依赖**：
- `data`：获取行情数据
- `config`：读取算法参数

---

## 二、模块架构

```
BreakthroughStrategy/analysis/
├── __init__.py
├── peak_detector.py          # PeakDetector - 凸点识别
├── breakout_detector.py      # BreakoutDetector - 突破检测
├── quality_scorer.py         # QualityScorer - 质量评分
└── indicators.py             # TechnicalIndicators - 技术指标
```

### 核心类关系

```
DataFrame → PeakDetector → List[Peak] → BreakoutDetector → List[Breakthrough]
                                ↓                               ↓
                         QualityScorer                   QualityScorer
                                ↓                               ↓
                          peak_quality_score            breakthrough_quality_score
```

---

## 三、核心数据结构

### 3.1 Peak（凸点）

```python
from dataclasses import dataclass
from datetime import date
from typing import Optional

@dataclass
class Peak:
    """凸点数据结构"""
    symbol: str                      # 股票代码
    date: date                       # 凸点日期
    price: float                     # 凸点价格（最高价）
    index: int                       # 在DataFrame中的索引位置

    # 凸点类型
    peak_type: str                   # 'normal' 或 'special'

    # 质量评估相关
    volume_surge_ratio: float        # 放量倍数（相对平均成交量）
    candle_change_pct: float         # K线涨跌幅
    left_suppression_days: int       # 左侧压制天数
    right_suppression_days: int      # 右侧压制天数
    merged_peaks_count: int          # 合并的凸点数量
    relative_height: float           # 相对高度（与相邻价位的差异）

    quality_score: Optional[float] = None  # 质量分数（0-100）

    def to_dict(self) -> dict:
        """转换为字典（用于存储）"""
        return {
            'symbol': self.symbol,
            'date': self.date.isoformat(),
            'price': self.price,
            'index': self.index,
            'peak_type': self.peak_type,
            'volume_surge_ratio': self.volume_surge_ratio,
            'candle_change_pct': self.candle_change_pct,
            'left_suppression_days': self.left_suppression_days,
            'right_suppression_days': self.right_suppression_days,
            'merged_peaks_count': self.merged_peaks_count,
            'relative_height': self.relative_height,
            'quality_score': self.quality_score
        }
```

### 3.2 Breakthrough（突破点）

```python
@dataclass
class Breakthrough:
    """突破点数据结构"""
    symbol: str
    date: date
    price: float                     # 突破价格（最高价）
    index: int

    # 关联的凸点
    peak: Peak
    exceed_pct: float                # 超越凸点的幅度

    # 突破类型
    breakthrough_type: str           # 'yang'(阳线), 'yin'(阴线), 'shadow'(上影线)

    # 质量评估相关
    price_change_pct: float          # 突破日涨跌幅
    gap_up: bool                     # 是否跳空
    gap_up_pct: float                # 跳空幅度
    volume_surge_ratio: float        # 放量倍数
    continuity_days: int             # 连续上涨天数
    stability_score: float           # 稳定性分数（突破后N日内的表现）

    quality_score: Optional[float] = None

    def to_dict(self) -> dict:
        return {
            'symbol': self.symbol,
            'date': self.date.isoformat(),
            'price': self.price,
            'index': self.index,
            'peak_date': self.peak.date.isoformat(),
            'peak_price': self.peak.price,
            'exceed_pct': self.exceed_pct,
            'breakthrough_type': self.breakthrough_type,
            'price_change_pct': self.price_change_pct,
            'gap_up': self.gap_up,
            'gap_up_pct': self.gap_up_pct,
            'volume_surge_ratio': self.volume_surge_ratio,
            'continuity_days': self.continuity_days,
            'stability_score': self.stability_score,
            'quality_score': self.quality_score
        }
```

---

## 四、PeakDetector（凸点识别）

### 4.1 核心算法

凸点识别分为两步：
1. **局部最高点检测**：找到所有高于两侧的点
2. **凸点合并**：合并价格相近的凸点

#### 算法1：局部最高点检测

```python
def detect_local_peaks(
    df: pd.DataFrame,
    lookback_bars: int = 20,
    lookforward_bars: int = 10
) -> List[Peak]:
    """
    检测局部最高点

    算法：
    1. 遍历DataFrame，对每个位置i：
       - 检查df.high[i]是否大于前lookback_bars和后lookforward_bars内的所有high
       - 如果是，则为凸点候选
    2. 计算凸点的各项指标（放量、涨跌幅、压制时间等）
    3. 返回凸点列表

    时间复杂度：O(n * (lookback + lookforward))
    """
    peaks = []
    n = len(df)

    for i in range(lookback_bars, n - lookforward_bars):
        current_high = df['high'].iloc[i]

        # 检查是否为局部最高点
        # 左侧检查
        left_max = df['high'].iloc[i - lookback_bars:i].max()
        # 右侧检查
        right_max = df['high'].iloc[i + 1:i + lookforward_bars + 1].max()

        if current_high > left_max and current_high >= right_max:
            # 计算凸点特征
            peak = _create_peak(df, i)
            peaks.append(peak)

    return peaks


def _create_peak(df: pd.DataFrame, index: int) -> Peak:
    """创建Peak对象并计算特征"""
    row = df.iloc[index]

    # 计算放量倍数
    avg_volume = df['volume'].iloc[max(0, index - 63):index].mean()  # 过去3个月平均
    volume_surge_ratio = row['volume'] / avg_volume if avg_volume > 0 else 1.0

    # 计算K线涨跌幅
    candle_change_pct = (row['high'] - row['low']) / row['low']

    # 计算压制时间（简化版：找到左右侧首次超过当前high的位置）
    left_suppression_days = _calculate_suppression_days(df, index, direction='left')
    right_suppression_days = _calculate_suppression_days(df, index, direction='right')

    # 计算相对高度
    relative_height = _calculate_relative_height(df, index)

    return Peak(
        symbol=df['symbol'].iloc[0],  # 假设symbol列存在
        date=df.index[index].date(),
        price=row['high'],
        index=index,
        peak_type='normal',  # 初始设为normal，特殊点需要额外检测
        volume_surge_ratio=volume_surge_ratio,
        candle_change_pct=candle_change_pct,
        left_suppression_days=left_suppression_days,
        right_suppression_days=right_suppression_days,
        merged_peaks_count=1,
        relative_height=relative_height
    )


def _calculate_suppression_days(df: pd.DataFrame, index: int, direction: str) -> int:
    """
    计算压制天数：从当前位置向左/右查找，直到找到高于当前high的K线
    """
    current_high = df['high'].iloc[index]
    days = 0

    if direction == 'left':
        # 向左查找
        for i in range(index - 1, -1, -1):
            if df['high'].iloc[i] > current_high:
                break
            days += 1
    else:
        # 向右查找
        for i in range(index + 1, len(df)):
            if df['high'].iloc[i] > current_high:
                break
            days += 1

    return days


def _calculate_relative_height(df: pd.DataFrame, index: int, window: int = 20) -> float:
    """
    计算相对高度：当前high与周围window内均值的差异百分比
    """
    current_high = df['high'].iloc[index]
    start = max(0, index - window)
    end = min(len(df), index + window + 1)
    avg_high = df['high'].iloc[start:end].mean()

    if avg_high > 0:
        return (current_high - avg_high) / avg_high
    return 0.0
```

#### 算法2：凸点合并

```python
def merge_nearby_peaks(
    peaks: List[Peak],
    merge_threshold_pct: float = 0.01  # 1%
) -> List[Peak]:
    """
    合并价格相近的凸点

    算法：
    1. 将凸点按价格排序
    2. 遍历凸点列表，如果相邻凸点价格差异 < threshold，则合并
    3. 合并规则：
       - 保留质量分数更高的凸点
       - 更新merged_peaks_count
       - 合并特征（如压制天数取最大值）

    时间复杂度：O(n log n)
    """
    if not peaks:
        return []

    # 按价格排序
    sorted_peaks = sorted(peaks, key=lambda p: p.price)
    merged = []

    i = 0
    while i < len(sorted_peaks):
        current = sorted_peaks[i]
        merge_group = [current]

        # 找到所有价格相近的凸点
        j = i + 1
        while j < len(sorted_peaks):
            next_peak = sorted_peaks[j]
            price_diff_pct = abs(next_peak.price - current.price) / current.price

            if price_diff_pct <= merge_threshold_pct:
                merge_group.append(next_peak)
                j += 1
            else:
                break

        # 合并
        if len(merge_group) > 1:
            merged_peak = _merge_peak_group(merge_group)
        else:
            merged_peak = current

        merged.append(merged_peak)
        i = j

    return merged


def _merge_peak_group(peaks: List[Peak]) -> Peak:
    """
    合并一组凸点

    合并规则：
    - 价格：取平均
    - 日期：取最早的
    - 压制天数：取最大值
    - 放量倍数：取最大值
    - merged_peaks_count：累加
    """
    # 找到放量最大的凸点作为代表
    representative = max(peaks, key=lambda p: p.volume_surge_ratio)

    # 更新合并信息
    representative.merged_peaks_count = len(peaks)
    representative.price = sum(p.price for p in peaks) / len(peaks)
    representative.date = min(p.date for p in peaks)
    representative.left_suppression_days = max(p.left_suppression_days for p in peaks)
    representative.right_suppression_days = max(p.right_suppression_days for p in peaks)
    representative.volume_surge_ratio = max(p.volume_surge_ratio for p in peaks)

    return representative
```

#### 算法3：特殊意义点检测

```python
def detect_special_peaks(df: pd.DataFrame, peaks: List[Peak]) -> List[Peak]:
    """
    检测特殊意义点（如导致大跌的K线高点）

    特征：
    1. 大跌K线：跌幅超过5%，且放量
    2. 该K线的high是后续一段时间的阻力位
    3. 即使不是局部最高点，也可能成为重要凸点

    算法：
    1. 遍历DataFrame，找到大跌K线
    2. 检查该K线的high是否在后续时间成为阻力
    3. 添加到凸点列表
    """
    special_peaks = []

    for i in range(len(df) - 30):  # 至少保留30天观察期
        row = df.iloc[i]

        # 判断是否为大跌K线
        change_pct = (row['close'] - row['open']) / row['open']
        avg_volume = df['volume'].iloc[max(0, i - 63):i].mean()
        volume_ratio = row['volume'] / avg_volume if avg_volume > 0 else 1.0

        if change_pct < -0.05 and volume_ratio > 2.0:  # 跌幅>5%，放量>2倍
            # 检查high是否成为后续阻力
            current_high = row['high']
            is_resistance = True

            # 检查后续30天
            for j in range(i + 1, min(i + 31, len(df))):
                if df['high'].iloc[j] > current_high * 1.05:  # 超过5%则不算阻力
                    is_resistance = False
                    break

            if is_resistance:
                # 创建特殊凸点
                peak = _create_peak(df, i)
                peak.peak_type = 'special'
                special_peaks.append(peak)

    return special_peaks
```

### 4.2 接口定义

```python
class PeakDetector:
    """凸点识别器"""

    def __init__(self, config: Optional[dict] = None):
        """
        初始化

        Args:
            config: 配置字典（包含lookback_bars, lookforward_bars等参数）
        """
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.lookback_bars = cfg.get('time.peak_lookback_bars', 20)
            self.lookforward_bars = cfg.get('time.peak_lookforward_bars', 10)
            self.merge_threshold_pct = cfg.get('quality.peak_merge_threshold_pct', 0.01)
        else:
            self.lookback_bars = config.get('lookback_bars', 20)
            self.lookforward_bars = config.get('lookforward_bars', 10)
            self.merge_threshold_pct = config.get('merge_threshold_pct', 0.01)

    def detect_peaks(
        self,
        df: pd.DataFrame,
        include_special: bool = True
    ) -> List[Peak]:
        """
        识别凸点

        Args:
            df: 行情数据（必须包含date, open, high, low, close, volume）
            include_special: 是否包含特殊意义点

        Returns:
            凸点列表（已按时间排序）
        """
        # 1. 检测局部最高点
        normal_peaks = detect_local_peaks(df, self.lookback_bars, self.lookforward_bars)

        # 2. 检测特殊意义点
        special_peaks = []
        if include_special:
            special_peaks = detect_special_peaks(df, normal_peaks)

        # 3. 合并所有凸点
        all_peaks = normal_peaks + special_peaks

        # 4. 合并相近凸点
        merged_peaks = merge_nearby_peaks(all_peaks, self.merge_threshold_pct)

        # 5. 按时间排序
        merged_peaks.sort(key=lambda p: p.index)

        return merged_peaks
```

---

## 五、BreakoutDetector（突破检测）

### 5.1 核心算法

```python
def detect_breakthroughs(
    df: pd.DataFrame,
    peaks: List[Peak],
    min_exceed_pct: float = 0.005  # 0.5%
) -> List[Breakthrough]:
    """
    检测突破点

    算法：
    1. 对每个凸点，向后查找是否有K线突破（high > peak.price）
    2. 确认突破：必须超过peak.price一定幅度（min_exceed_pct）
    3. 计算突破特征（类型、涨跌幅、跳空、放量、连续性等）
    4. 返回突破列表

    时间复杂度：O(n * m)，n为凸点数，m为平均查找距离
    """
    breakthroughs = []

    for peak in peaks:
        # 从凸点后一天开始查找
        search_start = peak.index + 1

        for i in range(search_start, len(df)):
            row = df.iloc[i]

            # 检查是否突破
            if row['high'] > peak.price * (1 + min_exceed_pct):
                # 确认突破，创建Breakthrough对象
                breakthrough = _create_breakthrough(df, i, peak)
                breakthroughs.append(breakthrough)
                break  # 每个凸点只记录第一次突破

    return breakthroughs


def _create_breakthrough(df: pd.DataFrame, index: int, peak: Peak) -> Breakthrough:
    """创建Breakthrough对象并计算特征"""
    row = df.iloc[index]

    # 突破超越幅度
    exceed_pct = (row['high'] - peak.price) / peak.price

    # 突破类型
    breakthrough_type = _classify_breakthrough_type(row)

    # 涨跌幅
    price_change_pct = (row['close'] - row['open']) / row['open']

    # 跳空检测
    gap_up = False
    gap_up_pct = 0.0
    if index > 0:
        prev_close = df['close'].iloc[index - 1]
        if row['open'] > prev_close:
            gap_up = True
            gap_up_pct = (row['open'] - prev_close) / prev_close

    # 放量倍数
    avg_volume = df['volume'].iloc[max(0, index - 63):index].mean()
    volume_surge_ratio = row['volume'] / avg_volume if avg_volume > 0 else 1.0

    # 连续性（连续上涨天数）
    continuity_days = _calculate_continuity(df, index)

    # 稳定性（突破后5天的表现）
    stability_score = _calculate_stability(df, index, peak.price)

    return Breakthrough(
        symbol=peak.symbol,
        date=df.index[index].date(),
        price=row['high'],
        index=index,
        peak=peak,
        exceed_pct=exceed_pct,
        breakthrough_type=breakthrough_type,
        price_change_pct=price_change_pct,
        gap_up=gap_up,
        gap_up_pct=gap_up_pct,
        volume_surge_ratio=volume_surge_ratio,
        continuity_days=continuity_days,
        stability_score=stability_score
    )


def _classify_breakthrough_type(row: pd.Series) -> str:
    """
    分类突破类型

    - 'yang': 阳线突破（close > open）
    - 'yin': 阴线突破（close < open）
    - 'shadow': 仅上影线突破（close和open都低于high）
    """
    if row['close'] > row['open']:
        return 'yang'
    elif row['close'] < row['open'] and row['close'] < row['high'] * 0.99:
        return 'shadow'
    else:
        return 'yin'


def _calculate_continuity(df: pd.DataFrame, index: int, lookback: int = 5) -> int:
    """
    计算连续上涨天数（向前查看lookback天）
    """
    count = 0
    for i in range(index - 1, max(-1, index - lookback - 1), -1):
        if df['close'].iloc[i] > df['close'].iloc[i - 1]:
            count += 1
        else:
            break
    return count


def _calculate_stability(
    df: pd.DataFrame,
    index: int,
    peak_price: float,
    lookforward: int = 5
) -> float:
    """
    计算稳定性：突破后N天内，最低价不跌破凸点价格，则稳定性高

    稳定性分数：
    - 100: 完全稳定，最低价始终高于凸点
    - 50: 部分回调，但收盘价高于凸点
    - 0: 跌破凸点
    """
    end = min(len(df), index + lookforward + 1)
    future_lows = df['low'].iloc[index + 1:end]
    future_closes = df['close'].iloc[index + 1:end]

    if len(future_lows) == 0:
        return 50.0  # 无法判断

    min_low = future_lows.min()
    min_close = future_closes.min()

    if min_low >= peak_price:
        return 100.0  # 完全稳定
    elif min_close >= peak_price:
        return 70.0  # 日内回调但收盘守住
    elif min_close >= peak_price * 0.98:
        return 40.0  # 轻微跌破
    else:
        return 0.0   # 明显跌破
```

### 5.2 接口定义

```python
class BreakoutDetector:
    """突破检测器"""

    def __init__(self, config: Optional[dict] = None):
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.min_exceed_pct = cfg.get('price.breakout_min_exceed_pct', 0.005)
        else:
            self.min_exceed_pct = config.get('min_exceed_pct', 0.005)

    def detect_breakthroughs(
        self,
        df: pd.DataFrame,
        peaks: List[Peak]
    ) -> List[Breakthrough]:
        """
        检测突破点

        Args:
            df: 行情数据
            peaks: 凸点列表

        Returns:
            突破点列表
        """
        return detect_breakthroughs(df, peaks, self.min_exceed_pct)
```

---

## 六、QualityScorer（质量评分）

### 6.1 凸点质量评分

```python
def score_peak_quality(peak: Peak, config: Optional[dict] = None) -> float:
    """
    凸点质量评分（0-100分）

    评分因素及权重（可配置）：
    1. 放量（25%）：volume_surge_ratio越大越好
    2. 长K线（20%）：candle_change_pct越大越好
    3. 压制时间（25%）：left_suppression_days + right_suppression_days越长越好
    4. 同价多凸点（15%）：merged_peaks_count越多越好
    5. 相对高度（15%）：relative_height越大越好
    """
    if config is None:
        # 默认权重
        weights = {
            'volume_surge': 0.25,
            'long_candle': 0.20,
            'suppression_time': 0.25,
            'multiple_peaks': 0.15,
            'relative_height': 0.15
        }
    else:
        weights = config.get('peak_quality_weights', {})

    # 1. 放量分数（0-100）
    # 假设放量2倍为50分，5倍为100分
    volume_score = min(100, (peak.volume_surge_ratio - 1) * 50)

    # 2. 长K线分数
    # 假设涨跌幅5%为50分，10%为100分
    candle_score = min(100, peak.candle_change_pct * 1000)

    # 3. 压制时间分数
    # 假设压制30天为50分，60天为100分
    total_suppression = peak.left_suppression_days + peak.right_suppression_days
    suppression_score = min(100, total_suppression * 100 / 60)

    # 4. 同价多凸点分数
    # 1个凸点0分，2个50分，3个及以上100分
    multiple_score = min(100, (peak.merged_peaks_count - 1) * 50)

    # 5. 相对高度分数
    # 假设高出5%为50分，10%为100分
    height_score = min(100, peak.relative_height * 1000)

    # 加权求和
    total_score = (
        volume_score * weights.get('volume_surge', 0.25) +
        candle_score * weights.get('long_candle', 0.20) +
        suppression_score * weights.get('suppression_time', 0.25) +
        multiple_score * weights.get('multiple_peaks', 0.15) +
        height_score * weights.get('relative_height', 0.15)
    )

    return total_score
```

### 6.2 突破质量评分

```python
def score_breakthrough_quality(breakthrough: Breakthrough, config: Optional[dict] = None) -> float:
    """
    突破质量评分（0-100分）

    评分因素及权重：
    1. 涨跌幅（25%）：price_change_pct越大越好
    2. 跳空（15%）：gap_up为True且gap_up_pct越大越好
    3. 放量（25%）：volume_surge_ratio越大越好
    4. 连续性（20%）：continuity_days越多越好
    5. 稳定性（15%）：stability_score越高越好
    """
    if config is None:
        weights = {
            'price_change': 0.25,
            'gap_up': 0.15,
            'volume_surge': 0.25,
            'continuity': 0.20,
            'stability': 0.15
        }
    else:
        weights = config.get('breakthrough_quality_weights', {})

    # 1. 涨跌幅分数
    # 假设涨幅3%为50分，6%为100分
    price_score = min(100, breakthrough.price_change_pct * 100 * 20)

    # 2. 跳空分数
    if breakthrough.gap_up:
        # 跳空1%为50分，2%为100分
        gap_score = min(100, breakthrough.gap_up_pct * 100 * 50)
    else:
        gap_score = 0

    # 3. 放量分数
    volume_score = min(100, (breakthrough.volume_surge_ratio - 1) * 50)

    # 4. 连续性分数
    # 连续上涨3天为50分，5天为100分
    continuity_score = min(100, breakthrough.continuity_days * 20)

    # 5. 稳定性分数（已经是0-100）
    stability_score = breakthrough.stability_score

    # 加权求和
    total_score = (
        price_score * weights.get('price_change', 0.25) +
        gap_score * weights.get('gap_up', 0.15) +
        volume_score * weights.get('volume_surge', 0.25) +
        continuity_score * weights.get('continuity', 0.20) +
        stability_score * weights.get('stability', 0.15)
    )

    return total_score
```

### 6.3 接口定义

```python
class QualityScorer:
    """质量评分器"""

    def __init__(self, config: Optional[dict] = None):
        if config is None:
            from BreakthroughStrategy.config import ConfigManager
            cfg = ConfigManager.get_instance()
            self.config = cfg.get_section('quality')
        else:
            self.config = config

    def score_peak(self, peak: Peak) -> float:
        """评估凸点质量"""
        score = score_peak_quality(peak, self.config)
        peak.quality_score = score
        return score

    def score_breakthrough(self, breakthrough: Breakthrough) -> float:
        """评估突破质量"""
        score = score_breakthrough_quality(breakthrough, self.config)
        breakthrough.quality_score = score
        return score

    def score_peaks_batch(self, peaks: List[Peak]) -> List[Peak]:
        """批量评分凸点"""
        for peak in peaks:
            self.score_peak(peak)
        return peaks

    def score_breakthroughs_batch(self, breakthroughs: List[Breakthrough]) -> List[Breakthrough]:
        """批量评分突破点"""
        for bt in breakthroughs:
            self.score_breakthrough(bt)
        return breakthroughs
```

---

## 七、TechnicalIndicators（技术指标）

```python
class TechnicalIndicators:
    """技术指标计算器"""

    @staticmethod
    def calculate_ma(series: pd.Series, period: int = 20) -> pd.Series:
        """计算移动平均线"""
        return series.rolling(window=period).mean()

    @staticmethod
    def calculate_rsi(close: pd.Series, period: int = 14) -> pd.Series:
        """
        计算RSI（相对强弱指标）

        RSI = 100 - 100 / (1 + RS)
        RS = 平均涨幅 / 平均跌幅
        """
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

        rs = gain / loss
        rsi = 100 - 100 / (1 + rs)
        return rsi

    @staticmethod
    def calculate_relative_volume(volume: pd.Series, period: int = 63) -> pd.Series:
        """
        计算相对成交量（当前成交量 / 过去N天平均成交量）
        """
        avg_volume = volume.rolling(window=period).mean()
        return volume / avg_volume

    @staticmethod
    def add_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """
        添加常用指标到DataFrame

        Args:
            df: 原始行情数据

        Returns:
            添加了指标列的DataFrame
        """
        df = df.copy()

        # 移动平均线
        df['ma_20'] = TechnicalIndicators.calculate_ma(df['close'], 20)
        df['ma_50'] = TechnicalIndicators.calculate_ma(df['close'], 50)

        # RSI
        df['rsi_14'] = TechnicalIndicators.calculate_rsi(df['close'], 14)

        # 相对成交量
        df['rv_63'] = TechnicalIndicators.calculate_relative_volume(df['volume'], 63)

        return df
```

---

## 八、使用示例

```python
from BreakthroughStrategy.analysis import PeakDetector, BreakoutDetector, QualityScorer
from BreakthroughStrategy.data import TigerDataAdapter
import pandas as pd

# 1. 获取数据
data_adapter = TigerDataAdapter()
df = data_adapter.get_historical_data('AAPL', '2023-01-01', '2024-01-01')

# 2. 识别凸点
peak_detector = PeakDetector()
peaks = peak_detector.detect_peaks(df)
print(f"Found {len(peaks)} peaks")

# 3. 检测突破
breakout_detector = BreakoutDetector()
breakthroughs = breakout_detector.detect_breakthroughs(df, peaks)
print(f"Found {len(breakthroughs)} breakthroughs")

# 4. 质量评分
scorer = QualityScorer()
scorer.score_peaks_batch(peaks)
scorer.score_breakthroughs_batch(breakthroughs)

# 5. 筛选高质量突破
high_quality = [bt for bt in breakthroughs if bt.quality_score > 70]
print(f"High quality breakthroughs: {len(high_quality)}")

# 6. 输出结果
for bt in high_quality:
    print(f"{bt.symbol} - {bt.date}: Breakthrough @ ${bt.price:.2f}, "
          f"Quality: {bt.quality_score:.1f}, "
          f"Peak: ${bt.peak.price:.2f} ({bt.peak.date})")
```

---

## 九、性能优化

### 9.1 向量化计算

使用pandas/numpy向量化操作替代Python循环：

```python
# 慢速版本（Python循环）
def calculate_ma_slow(series, period):
    result = []
    for i in range(len(series)):
        if i < period - 1:
            result.append(np.nan)
        else:
            result.append(series[i - period + 1:i + 1].mean())
    return pd.Series(result)

# 快速版本（向量化）
def calculate_ma_fast(series, period):
    return series.rolling(window=period).mean()

# 性能提升：约10-100倍
```

### 9.2 并行处理

对多只股票进行分析时，使用多进程：

```python
from multiprocessing import Pool
from functools import partial

def analyze_symbol(symbol, start_date, end_date):
    """分析单只股票"""
    # ... 凸点识别、突破检测、质量评分
    return results

def analyze_symbols_parallel(symbols, start_date, end_date, workers=8):
    """并行分析多只股票"""
    with Pool(workers) as pool:
        func = partial(analyze_symbol, start_date=start_date, end_date=end_date)
        results = pool.map(func, symbols)
    return results
```

---

## 十、测试方案

### 10.1 单元测试

```python
# tests/analysis/test_peak_detector.py
import pytest
from BreakthroughStrategy.analysis.peak_detector import PeakDetector
import pandas as pd
import numpy as np

class TestPeakDetector:

    @pytest.fixture
    def sample_data(self):
        """生成测试数据"""
        dates = pd.date_range('2023-01-01', periods=100, freq='D')
        # 创建带有明显凸点的数据
        prices = np.random.randn(100).cumsum() + 100
        prices[50] = prices[50] + 10  # 创建凸点

        df = pd.DataFrame({
            'date': dates,
            'open': prices,
            'high': prices + np.random.rand(100),
            'low': prices - np.random.rand(100),
            'close': prices + np.random.randn(100) * 0.5,
            'volume': np.random.randint(1000000, 10000000, 100)
        })
        df.set_index('date', inplace=True)
        df['symbol'] = 'TEST'
        return df

    def test_detect_peaks(self, sample_data):
        """测试凸点识别"""
        detector = PeakDetector()
        peaks = detector.detect_peaks(sample_data)

        assert len(peaks) > 0
        assert all(isinstance(p.price, float) for p in peaks)
        assert all(p.quality_score is None for p in peaks)  # 未评分

    def test_merge_peaks(self):
        """测试凸点合并"""
        # 创建价格相近的凸点
        from BreakthroughStrategy.analysis.peak_detector import Peak, merge_nearby_peaks
        from datetime import date

        peaks = [
            Peak('TEST', date(2023, 1, 1), 100.0, 10, 'normal', 2.0, 0.05, 10, 10, 1, 0.05),
            Peak('TEST', date(2023, 1, 2), 100.5, 11, 'normal', 2.5, 0.06, 12, 12, 1, 0.06),
            Peak('TEST', date(2023, 1, 3), 105.0, 12, 'normal', 3.0, 0.07, 15, 15, 1, 0.07),
        ]

        merged = merge_nearby_peaks(peaks, merge_threshold_pct=0.01)

        # 前两个应该合并（价格差<1%），第三个独立
        assert len(merged) == 2
        assert merged[0].merged_peaks_count == 2

# tests/analysis/test_quality_scorer.py
class TestQualityScorer:

    def test_score_peak(self):
        """测试凸点评分"""
        from BreakthroughStrategy.analysis.quality_scorer import QualityScorer
        from BreakthroughStrategy.analysis.peak_detector import Peak
        from datetime import date

        peak = Peak(
            symbol='TEST',
            date=date(2023, 1, 1),
            price=100.0,
            index=50,
            peak_type='normal',
            volume_surge_ratio=3.0,  # 放量3倍
            candle_change_pct=0.08,  # 涨跌幅8%
            left_suppression_days=30,
            right_suppression_days=20,
            merged_peaks_count=2,
            relative_height=0.10
        )

        scorer = QualityScorer()
        score = scorer.score_peak(peak)

        assert 0 <= score <= 100
        assert peak.quality_score == score
        # 高质量凸点应该得分较高
        assert score > 60
```

---

## 十一、待优化事项

1. **算法参数调优**：
   - 当前参数（lookback_bars=20等）是初始值，需要通过回测优化
   - 建议使用Optuna进行参数寻优

2. **特殊凸点检测**：
   - 当前只实现了大跌K线高点检测
   - 可以增加其他类型（如底部反弹的首个高点、突破新高后的回调点等）

3. **质量评分模型**：
   - 当前使用线性加权评分
   - 后期可考虑使用机器学习模型（如XGBoost）学习更复杂的评分函数

4. **假突破过滤**：
   - 当前使用stability_score简单判断
   - 可以增加更复杂的假突破识别逻辑

---

**文档状态**：初稿完成
**下一步**：编写数据层设计文档
