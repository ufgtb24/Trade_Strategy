# 影线过滤（Shadow Filter）实现指南

> **实现难度**：⭐ 极简
> **预计时间**：30分钟
> **测试周期**：1-2周

---

## 一、快速参考

### 核心公式

```
shadow_ratio = (high - max(open, close)) / max(open, close)

if shadow_ratio > shadow_threshold:  # 例如 0.03（3%）
    peak_price = max(open, close)     # 使用实体上界
else:
    peak_price = high                 # 使用最高价
```

### 新增配置参数

```yaml
# BreakthroughDetector 初始化参数
shadow_threshold: 0.03         # 上影线阈值（推荐值：2-5%）
apply_shadow_filter: true      # 是否启用影线过滤
```

---

## 二、代码改动清单

### 2.1 BreakthroughDetector 初始化

**文件**：`BreakthroughStrategy/analysis/breakthrough_detector.py`

**改动位置**：`__init__()` 方法（第184-215行）

```python
def __init__(self,
             symbol: str,
             total_window: int = 10,
             min_side_bars: int = 2,
             min_relative_height: float = 0.05,
             min_local_prominence: float = 0.03,
             min_strict_height: float = 0.15,
             exceed_threshold: float = 0.005,
             peak_supersede_threshold: float = 0.03,
             momentum_window: int = 20,
             # ========== 新增参数 ==========
             shadow_threshold: float = 0.03,      # NEW
             apply_shadow_filter: bool = True,    # NEW
             # ==============================
             use_cache: bool = False,
             cache_dir: str = "./cache"):
    """
    初始化突破检测器

    Args:
        ...
        shadow_threshold: 上影线相对实体上界的阈值（默认3%）
                         影线长度 = (high - entity_top) / entity_top
        apply_shadow_filter: 是否启用影线过滤
    """
    # ... existing code ...

    # 新增属性
    self.shadow_threshold = shadow_threshold
    self.apply_shadow_filter = apply_shadow_filter
```

### 2.2 新增辅助方法

**在 `_check_breakouts()` 前添加**（约第480行）：

```python
def _get_effective_price(self, high: float, open_price: float, close: float) -> float:
    """
    获取有效价格（应用影线过滤）

    Args:
        high: 最高价
        open_price: 开盘价
        close: 收盘价

    Returns:
        有效价格（考虑影线过滤）
    """
    if not self.apply_shadow_filter:
        return high

    entity_top = max(open_price, close)

    if entity_top <= 0:
        return high

    shadow_ratio = (high - entity_top) / entity_top

    # 如果上影线过长，使用实体上界
    if shadow_ratio > self.shadow_threshold:
        return entity_top
    else:
        return high
```

### 2.3 改动 `add_bar()` 方法

**原始代码**（第255-300行）：
```python
def add_bar(self, row: pd.Series, auto_save: bool = True) -> Optional[BreakoutInfo]:
    ...
    # 2. 再检查突破（使用high价格）
    breakout_info = self._check_breakouts(current_idx, high, bar_date)
    ...
```

**改为**：
```python
def add_bar(self, row: pd.Series, auto_save: bool = True) -> Optional[BreakoutInfo]:
    ...
    # 2. 再检查突破（使用有效价格）
    effective_price = self._get_effective_price(high, open_price, price)  # NEW
    breakout_info = self._check_breakouts(current_idx, effective_price, bar_date)
    ...
```

### 2.4 改动 `_check_breakouts()` 方法签名

**原始代码**（第482-507行）：
```python
def _check_breakouts(self,
                    current_idx: int,
                    current_high: float,        # 重命名为 effective_price
                    current_date: date) -> Optional[BreakoutInfo]:
    """检查突破"""
    ...
    if current_high > exceed_threshold_price:
        ...
```

**改为**：
```python
def _check_breakouts(self,
                    current_idx: int,
                    effective_price: float,     # 改名：强调是经过过滤的有效价格
                    current_date: date) -> Optional[BreakoutInfo]:
    """检查突破（使用有效价格，已应用影线过滤）"""
    ...
    if effective_price > exceed_threshold_price:
        ...
```

### 2.5 缓存支持（可选）

**改动 `_save_cache()` 和 `_load_cache()`**：

```python
def _save_cache(self):
    """保存缓存到磁盘"""
    cache_data = {
        ...
        'shadow_threshold': self.shadow_threshold,      # NEW
        'apply_shadow_filter': self.apply_shadow_filter, # NEW
        ...
    }

def _load_cache(self):
    """从磁盘加载缓存"""
    # 验证参数匹配
    if (cache_data.get('shadow_threshold') != self.shadow_threshold or
        cache_data.get('apply_shadow_filter') != self.apply_shadow_filter):
        print(f"⚠ 缓存参数不匹配，跳过加载")
        return False
```

---

## 三、配置文件更新

### 3.1 UI参数配置

**文件**：`configs/analysis/params/ui_params.yaml`

添加以下内容：
```yaml
# 影线过滤配置
shadow_threshold: 0.03        # 上影线阈值（%）
apply_shadow_filter: true     # 是否启用影线过滤

# 选项说明
# shadow_threshold:
#   - 0.02: 激进，过滤大部分虚假上影线
#   - 0.03: 平衡（推荐）
#   - 0.05: 保守，仅过滤极端情况
```

### 3.2 通用配置

**文件**：`configs/analysis/config.yaml`

在 analysis 部分添加：
```yaml
# 峰值检测 - 影线过滤
shadow_threshold: 0.03
apply_shadow_filter: true
```

---

## 四、集成步骤

### 步骤1：代码改动（15分钟）

```bash
# 1. 打开 breakthrough_detector.py
# 2. 执行上述代码改动
# 3. 保存文件
```

### 步骤2：单元测试（15分钟）

```python
# tests/test_shadow_filter.py

def test_shadow_filter_basic():
    """测试影线过滤基础功能"""
    detector = BreakthroughDetector(
        'TEST',
        shadow_threshold=0.03,
        apply_shadow_filter=True
    )

    # 测试用例1：无上影线
    # high=100, open=99, close=99.5
    # entity_top=99.5, shadow_ratio=(100-99.5)/99.5=0.5% < 3%
    # → 使用 high=100

    # 测试用例2：长上影线
    # high=103, open=100, close=100.5
    # entity_top=100.5, shadow_ratio=(103-100.5)/100.5=2.49% ≈ 2.5% < 3%
    # → 使用 high=103（临界，不过滤）

    # 测试用例3：极长上影线
    # high=105, open=100, close=100.5
    # entity_top=100.5, shadow_ratio=(105-100.5)/100.5=4.48% > 3%
    # → 使用 entity_top=100.5（过滤）
```

### 步骤3：集成测试（30分钟）

```python
# 使用现有的集成测试框架
# BreakthroughStrategy/analysis/test/test_integrated_system.py

# 对比测试：同一数据集，影线过滤开启vs关闭
# 观察突破数量、峰值识别准确性变化
```

### 步骤4：参数调优（1周）

测试以下阈值组合：

| shadow_threshold | 特性 | 适用场景 |
|-----------------|------|--------|
| 0.02 | 激进过滤 | 低波动率股票 |
| 0.03 | 平衡（推荐） | 通用 |
| 0.04 | 中等过滤 | 高波动率股票 |
| 0.05 | 保守过滤 | 极端情况 |

**测试方法**：
```python
for threshold in [0.02, 0.03, 0.04, 0.05]:
    detector = BreakthroughDetector(..., shadow_threshold=threshold)
    breakouts = detector.batch_add_bars(df)

    metrics = {
        'num_breakouts': len(breakouts),
        'avg_quality_score': np.mean([...]),  # 需计算
        'false_positive_ratio': ...,          # 需人工标注
    }

    print(f"Threshold {threshold}: {metrics}")
```

---

## 五、对比验证

### 实验设计

**对照组**：`apply_shadow_filter=False`（原始方案）
**实验组**：`apply_shadow_filter=True`（影线过滤方案）

**选择测试股票**：选5-10只不同特征的股票
- 低波动率（如：MSFT）
- 高波动率（如：TSLA）
- 高科技（如：NVDA）
- 医药（如：JNJ）

**关键指标**：

| 指标 | 预期改进 |
|------|---------|
| **假突破率** | ↓ 降低10-20% |
| **峰值准确度** | ↑ 提升15-25% |
| **平均质量评分** | ↑ 提升5-10% |
| **突破数量** | ↔ 略有变化（-5%到+5%） |

### 验证代码示例

```python
def compare_shadow_filter_effect(symbol: str, df: pd.DataFrame):
    """对比影线过滤效果"""

    # 原始方案
    detector_orig = BreakthroughDetector(
        symbol,
        apply_shadow_filter=False
    )
    breakouts_orig = detector_orig.batch_add_bars(df, return_breakouts=True)

    # 影线过滤方案
    detector_filter = BreakthroughDetector(
        symbol,
        apply_shadow_filter=True,
        shadow_threshold=0.03
    )
    breakouts_filter = detector_filter.batch_add_bars(df, return_breakouts=True)

    print(f"Symbol: {symbol}")
    print(f"  原始方案: {len(breakouts_orig)} 个突破")
    print(f"  影线过滤: {len(breakouts_filter)} 个突破")
    print(f"  差异: {len(breakouts_orig) - len(breakouts_filter):+d} "
          f"({(len(breakouts_orig) - len(breakouts_filter)) / len(breakouts_orig) * 100:+.1f}%)")
```

---

## 六、回滚方案

如果需要快速回滚，仅需：

```python
# 方案A：通过参数禁用
detector = BreakthroughDetector(..., apply_shadow_filter=False)

# 方案B：通过阈值禁用（影线永不过长）
detector = BreakthroughDetector(..., shadow_threshold=999.0)
```

---

## 七、与评分系统的配合

### Bonus模型中的补偿机制

若影线过滤导致某些突破被判定为"弱"，可在评分中补偿：

**推荐方式1：增强Volume Bonus**
```python
# 如果突破日有长上影线但实体强势
# 则在评分时给予Volume Bonus额外权重
```

**推荐方式2：新增ShadowQuality Bonus**
```python
shadow_bonus = BonusDetail(
    name="ShadowQuality",
    raw_value=shadow_ratio,
    unit="%",
    bonus=1.10 if shadow_ratio > threshold else 1.0,
    triggered=(shadow_ratio > threshold),
    level=1
)
```

**当前建议**：暂不在评分中特殊处理，让数据说话。如果效果不理想，再考虑补偿。

---

## 八、常见问题

### Q1: 为什么不直接用close而是max(open, close)？

**A**:
- **close** 可能低于open（阴线），无法代表推动力
- **max(open, close)** 代表K线实体的顶部，才是真实推动力
- 例如：10:00开于100，13:00最高103，15:00收盘101
  - high=103 可能是虚假跳水前的回试
  - entity_top=101 才是真实意愿

### Q2: 为什么threshold设为3%而不是其他值？

**A**:
- **2%** 太敏感，可能过滤有效的长上影线突破
- **3%** 是技术分析中的标准阈值（"峰值重叠"定义）
- **5%** 太保守，许多虚假上影线都会被保留

建议先用3%，后续通过A/B测试调整。

### Q3: 影线过滤会影响"上影线突破"的识别吗？

**A**: 有小幅影响，但是正向的：
- **弱上影线突破**（shadow_ratio < 3%）：仍使用high，正常识别
- **强上影线突破**（shadow_ratio > 3%）：使用entity_top，更保守但更准确
  - 这类突破往往是虚假的（上影线陷阱）
  - 评分系统会通过其他因素（Volume, Continuity等）识别真实强势突破

### Q4: 这会增加计算成本吗？

**A**: 否。仅增加两次比较和一次计算，O(1)复杂度，可忽略不计。

### Q5: 可以根据股票特性动态调整threshold吗？

**A**: 可以，但初期不建议：
- 动态调整增加复杂度
- 先用固定3%验证有效性
- 后续可考虑：
  - 基于波动率的自适应阈值
  - 基于K线形态的条件阈值
  - 但需充分回测验证

---

## 九、预期时间表

| 阶段 | 任务 | 时间 | 负责人 |
|------|------|------|--------|
| **第1周** | 代码改动 + 单元测试 | 2天 | 开发 |
| **第1周** | 集成测试（5只股票） | 2天 | 测试 |
| **第2周** | 参数调优（shadow_threshold） | 3天 | 数据分析 |
| **第2周** | A/B对比测试 | 2天 | 测试 |
| **第3周** | 回测验证（完整策略） | 5天 | 回测 |
| **第4周** | 性能报告 + 决策 | 2天 | PM |

**总计**：3-4周

---

## 十、成功标准

✅ **实现成功的指标**：

1. **代码质量**
   - [ ] 单元测试通过率 100%
   - [ ] 无新增WARNINGS（代码规范）

2. **功能正确性**
   - [ ] 集成测试通过（5只测试股票）
   - [ ] 影线过滤逻辑验证正确

3. **性能验证**
   - [ ] 突破精准度 ↑ > 10%
   - [ ] 假突破率 ↓ > 15%
   - [ ] 计算时间增加 < 1%

4. **系统兼容性**
   - [ ] 现有模块无破坏（向后兼容）
   - [ ] 缓存兼容性验证

5. **文档完整性**
   - [ ] 代码注释完整
   - [ ] 使用文档更新
   - [ ] 配置参数文档化

---

**实现指南维护者**：Claude Code
**最后更新**：2025-12-23
