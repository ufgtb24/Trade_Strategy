# 峰值阻力模型架构研究：Active Peaks vs 时间衰减+成交量模型

**研究日期**: 2025-12-13
**研究背景**: 探讨是否应该放弃当前的 `active_peaks` 机制，改用基于时间衰减和成交量的连续权重模型
**分析方法**: 多角度并行分析（技术分析理论、市场微观结构、量化实现、实证验证）

---

## 执行摘要

### 核心问题

当前系统使用 `active_peaks` 概念管理峰值：
- 峰值被突破后从活跃列表移除
- 问题：假突破后回落时，已移除的峰值无法重新发挥阻力作用

用户提出新观点：
> 峰值的阻力作用不再取决于是否被突破，而是取决于**时间衰减**和**成交量**

### 综合结论

| 评估维度 | 评分 | 说明 |
|---------|------|------|
| 理论合理性 | ★★★★☆ | 符合技术分析和市场微观结构理论 |
| 实证可验证性 | ★★★★★ | 可设计明确的对照实验 |
| 实施复杂度 | ★★★☆☆ | 中等，需要重构核心数据结构 |
| 过拟合风险 | ★★★★☆ | 较高，新增约10个参数 |

**最终建议**: 采用**混合方案**，保留 `active_peaks` 概念但增加权重维度，分阶段渐进式改进。

---

## 1. 技术分析理论角度

### 1.1 时间衰减的理论支持

**道氏理论与支撑阻力理论的核心观点：**

| 时间距离 | 阻力强度 | 理论依据 |
|---------|---------|---------|
| 1个月内 | 100% | 市场记忆清晰，套牢盘完整 |
| 3-6个月 | 60-80% | 部分止损离场，记忆开始淡化 |
| 6-12个月 | 30-50% | 市场结构变化，大量换手稀释 |
| 12个月以上 | <30% | 基本失效，除非是历史最高价 |

**结论**: 时间衰减模型**符合**传统技术分析原理。

### 1.2 成交量的核心作用

**威科夫方法论（Wyckoff Method）和 VSA 分析的核心观点：**

```
高成交量峰值 → 大量换手 → 大量套牢盘聚集 → 强阻力
低成交量峰值 → 少量换手 → 稀疏套牢盘 → 弱阻力
```

**结论**: 成交量是阻力强度的**核心衡量标准**，这在传统理论中有坚实基础。

### 1.3 被突破阻力位的命运

**支撑阻力转换原理：**

```
场景 1: 有效突破
价格 ──→ 突破阻力 ──→ 回落测试 ──→ 获得支撑反弹
               ↓
         原阻力变支撑

场景 2: 假突破（图中 36 突破后回落的情况）
价格 ──→ 短暂突破 ──→ 快速跌回 ──→ 阻力重新生效
               ↓
         峰值阻力被"确认"而非消除
```

**结论**: 阻力位**不是永久失效**，假突破后可以重新生效。

---

## 2. 市场微观结构角度

### 2.1 套牢盘的时间演化

**套牢盘随时间衰减的机制：**

1. **主动割肉离场**：短期投资者承受不了亏损压力，选择止损
2. **被动换手稀释**：市场持续交易导致筹码换手，原套牢盘被新资金稀释
3. **心理遗忘效应**：投资者对远期亏损的痛感减弱

**关键时间节点：**
- 1个月内：套牢盘情绪强烈，抛压最大
- 3-6个月：部分套牢盘已离场，但仍有较强阻力
- 1年以上：市场记忆显著衰减，阻力作用大幅下降

### 2.2 假突破后的套牢盘重新积累

**当前系统的缺陷：**

```python
# 当前逻辑 (breakthrough_detector.py)
if current_high > threshold:
    broken_peaks.append(peak)  # 突破后从 active_peaks 移除
```

**问题分析：**
- 峰值被突破后立即移除，但突破日本身可能形成新的套牢盘
- 如果突破后回落（假突破），在突破价位买入的投资者成为新套牢群体
- 第二次挑战该阻力位时，面临**双重抛压**（原峰值 + 突破日套牢盘）

### 2.3 结论

**时间衰减 + 成交量模型高度合理，原因：**
1. 套牢盘是实体存在，不是虚幻的"阻力"
2. 时间导致套牢盘离场和筹码稀释
3. 成交量决定套牢盘的初始规模
4. 优于当前 active_peaks 的二元模型

---

## 3. 量化实现角度

### 3.1 当前方案（active_peaks）评估

| 维度 | 优点 | 缺点 |
|-----|------|------|
| 状态管理 | 清晰简洁（活跃/移除） | 无法处理假突破回落 |
| 计算效率 | O(P), P≈5-10 | - |
| 可解释性 | 高（3%阈值语义明确） | 二元逻辑过于简化 |
| 时间因素 | - | 不区分新峰值和老峰值 |

### 3.2 新方案设计考虑

#### 时间衰减函数推荐

**指数衰减（半衰期模型）- 推荐**

```python
def exponential_decay(days_ago: int, half_life: int = 30) -> float:
    """
    指数衰减
    - 10天前峰值: 0.79 (高权重)
    - 30天前峰值: 0.50 (中等权重)
    - 60天前峰值: 0.25 (低权重)
    - 90天前峰值: 0.125 (很低权重)
    """
    return 0.5 ** (days_ago / half_life)
```

#### 成交量强化系数

```python
def volume_multiplier(volume_surge_ratio: float) -> float:
    """
    成交量强化系数
    - >= 5.0x: 权重 +20%
    - >= 3.0x: 权重 +10%
    - >= 2.0x: 权重不变
    - < 1.5x:  权重 -20%
    """
    if volume_surge_ratio >= 5.0:
        return 1.2
    elif volume_surge_ratio >= 3.0:
        return 1.1
    elif volume_surge_ratio >= 2.0:
        return 1.0
    else:
        return 0.8
```

### 3.3 实现复杂度对比

| 维度 | 当前方案 | 新方案（全衰减） | 混合方案（推荐） |
|------|---------|----------------|-----------------|
| 代码行数 | 565 行 | ~800 行 (+40%) | ~650 行 (+15%) |
| 核心参数 | 3 个 | 7+ 个 | 5 个 |
| 时间复杂度 | O(P), P≈5-10 | O(P), P≈50-100 | O(P), P≈10-30 |
| 调参难度 | 低 | 高 | 中 |
| 过拟合风险 | 低 | 高 | 中 |

### 3.4 推荐：混合方案

**核心思路：保留 `active_peaks` 概念，增加权重维度**

```python
@dataclass
class WeightedPeak(Peak):
    """带权重的峰值"""
    weight: float = 1.0           # 初始权重 1.0（完全活跃）
    created_date: date = None     # 峰值创建日期
    last_tested_date: date = None # 最后被测试日期
    test_count: int = 0           # 被测试次数

def _check_breakouts(self, current_idx, current_high, current_date):
    for peak in self.active_peaks:
        # 1. 更新权重（时间衰减）
        days_ago = (current_date - peak.created_date).days
        peak.weight = 0.5 ** (days_ago / 30)

        # 2. 移除低权重峰值（自动清理）
        if peak.weight < 0.05:
            continue

        # 3. 突破后权重降低（而非直接删除）
        if current_high > threshold:
            exceed_pct = (current_high - peak.price) / peak.price
            if exceed_pct > self.peak_supersede_threshold:
                peak.weight *= 0.2   # 大幅突破，权重降至 20%
            else:
                peak.weight *= 0.7   # 小幅突破，权重降至 70%

            # 仍然保留（除非权重太低）
            if peak.weight >= 0.05:
                remaining_peaks.append(peak)
```

---

## 4. 实证验证角度

### 4.1 可验证的假设

| 假设 | 验证方法 | 预期结果 |
|-----|---------|---------|
| H1: 阻力随时间衰减 | 分组分析：不同年龄峰值的突破成功率 | 老峰值突破成功率更高 |
| H2: 高成交量=强阻力 | 相关性分析：成交量 vs 回落概率 | 显著正相关 |
| H3: 假突破强化阻力 | 对比：有/无失败突破历史的峰值表现 | 有历史的阻力更强 |

### 4.2 评估指标设计

```python
# 核心指标
def evaluate_resistance_strength(peak, lookforward_days=10):
    return {
        'success_rate': 突破后N天内价格持续在峰值上方的概率,
        'pullback_prob': 突破后N天内价格回落至峰值以下的概率,
        'avg_return': 突破后N天的平均收益率,
        'time_to_bt': 从峰值形成到被成功突破的平均时间
    }
```

### 4.3 回测实验设计

```python
# 对照实验
strategies = {
    'baseline': 'Active Peaks (当前)',
    'time_decay_linear': '线性时间衰减',
    'time_decay_exp': '指数时间衰减（半衰期30天）',
    'volume_weighted': '成交量加权',
    'combined': '时间衰减 + 成交量组合'
}

# 数据需求
- 时间范围：至少 2-3 年
- 股票池：500-1000 只
- 样本量：10000+ 个突破事件
```

### 4.4 避免过拟合的措施

1. **时间序列交叉验证**（Expanding Window）
2. **参数搜索空间限制**（仅 3-5 个候选值/参数）
3. **样本外测试**（严格封存 2023-2024 数据）
4. **统计显著性检验**（p < 0.05）
5. **AIC/BIC 信息准则**（评估模型复杂度收益）

### 4.5 风险评估

| 风险 | 严重程度 | 缓解措施 |
|-----|---------|---------|
| 参数过多（~30个） | 高 | 分阶段引入，参数共享 |
| 训练-测试性能差距 | 中 | 差距 >20% 判定为过拟合 |
| 计算复杂度增加 | 低 | 定期清理低权重峰值 |

---

## 5. 综合结论与建议

### 5.1 各角度结论汇总

| 分析角度 | 对新方案的支持度 | 关键洞察 |
|---------|-----------------|---------|
| 技术分析理论 | ★★★★★ 强烈支持 | 完全符合支撑阻力理论和成交量原则 |
| 市场微观结构 | ★★★★★ 强烈支持 | 套牢盘时间演化规律验证了时间衰减 |
| 量化实现 | ★★★☆☆ 中等支持 | 建议混合方案，避免过度工程 |
| 实证验证 | ★★★★☆ 支持但需验证 | 理论合理，但需数据证明 |

### 5.2 最终建议：分阶段实施

```
┌─────────────────────────────────────────────────────────────────┐
│  阶段 1：增强当前方案（1-2周）                                    │
│  ├─ 添加峰值"重要性"标记（is_major）                              │
│  └─ 添加峰值"复活"机制（处理假突破）                              │
│      改动量：<50行代码                                           │
├─────────────────────────────────────────────────────────────────┤
│  阶段 2：混合方案试验（1-2月）                                    │
│  ├─ 为 Peak 添加 weight 字段                                     │
│  ├─ 实现时间衰减（指数，半衰期30天）                              │
│  └─ 回测对比（20-50只股票）                                       │
│      验收条件：胜率提升 >5%                                       │
├─────────────────────────────────────────────────────────────────┤
│  阶段 3：完整方案（如阶段2验证通过）                              │
│  ├─ 整合成交量强化系数                                           │
│  ├─ 添加突破历史追踪                                             │
│  └─ 发布 v2.0 版本                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 不推荐的方向

- ❌ 直接实现全时间衰减方案（复杂度过高，效果不确定）
- ❌ 完全放弃 `active_peaks`（丢失清晰的语义和性能优势）
- ❌ 同时引入所有新特征（过拟合风险极高）
- ❌ 没有回测验证的参数调优（必然过拟合）

### 5.4 关键设计原则

1. **简单优于复杂**：除非复杂模型有明确的收益提升证据
2. **增量改进**：从现有系统出发，逐步迭代
3. **数据驱动**：用回测验证，而非理论推导
4. **可解释性**：交易员需要理解系统的决策逻辑

---

## 6. 阶段 1 实施方案（立即可行）

### 6.1 峰值"复活"机制

```python
# 在 BreakthroughDetector 中增加
class BreakthroughDetector:
    def __init__(self, ...):
        ...
        self.recently_removed = []  # 最近移除的峰值（保留30天）

    def add_bar(self, row, auto_save=True):
        # ... 现有逻辑 ...

        # 检查是否应该恢复峰值（假突破后回落）
        current_close = row['close']
        for removed_peak in list(self.recently_removed):
            days_since_removal = (current_date - removed_peak.removed_date).days

            # 条件：30天内，价格回落到峰值下方
            if days_since_removal < 30 and current_close < removed_peak.price:
                # 恢复峰值
                self.active_peaks.append(removed_peak)
                self.recently_removed.remove(removed_peak)
```

### 6.2 峰值"重要性"标记

```python
@dataclass
class Peak:
    # ... 现有字段 ...
    is_major: bool = False  # 是否为重要阻力位

def _create_peak(self, idx, price, date_val):
    peak = Peak(...)

    # 判断是否为重要阻力位
    if peak.quality_score and peak.quality_score > 80:
        if peak.left_suppression_days > 40:
            peak.is_major = True

    return peak

def _check_breakouts(self, ...):
    for peak in self.active_peaks:
        # 重要峰值需要更大幅度突破
        if peak.is_major:
            threshold = peak.price * (1 + 0.05)  # 5%
        else:
            threshold = peak.price * (1 + self.exceed_threshold)  # 0.5%
```

---

## 附录：相关文件

- 当前实现：`BreakthroughStrategy/analysis/breakthrough_detector.py`
- 质量评分：`BreakthroughStrategy/analysis/quality_scorer.py`
- 设计文档：`docs/modules/specs/02_技术分析模块_IMPL.md`
- 参数配置：`configs/analysis/params/ui_params.yaml`

---

**研究者**: Claude Code (Multi-Agent Analysis)
**分析方法**: 4个专业子代理并行分析 + 综合汇总
